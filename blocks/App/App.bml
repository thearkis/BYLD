const api = `https://o8a3bj9a.api.sanity.io/v2022-03-07/data/query/production?query=`


Beast.decl({
    'ae__show-item': {
        expand: function () {
            this.append(
                this.get('video'),
            )
        },
        domInit: function fn () {

            

            

            var films = document.querySelectorAll('video');

            var promise = new Promise(function(resolve) {
                var loaded = 0;

                films.forEach(function(v) {
                    v.addEventListener('loadedmetadata', function() {
                        loaded++;

                    if (loaded === films.length) {
                        resolve();
                    }
                    });
                });
            });

            
            promise.then(function() {
              films.forEach(function(v) {
                v.muted = true;
                v.play();
              });
            });

        }
    },
    
    'AE__video': {
        tag:'video',
        expand: function () {
            this.domAttr('muted', 'true')
            this.domAttr('autoplay', 'true')
            this.domAttr('playsinline', 'true')
            this.domAttr('loop', 'true')
            this.domAttr('id', 'video')
            
            this.append(
                <source source="{this.text()}"></source>
            )
        }
    },
    'AE__source': {
        tag:'source',
        expand: function () {
            let src = this.param('source')
            this.domAttr('src', src)
            this.domAttr('type', 'video/mp4')
            
        }
    } 
})

Beast.decl({
    Phone: {
        expand: function () {
            this.append(
                this.get('video'),
            )
        },
        domInit: function fn () {

            var films = document.querySelectorAll('video');

            var promise = new Promise(function(resolve) {
                var loaded = 0;

                films.forEach(function(v) {
                    v.addEventListener('loadedmetadata', function() {
                        loaded++;

                    if (loaded === films.length) {
                        resolve();
                    }
                    });
                });
            });

            
            promise.then(function() {
              films.forEach(function(v) {
                v.muted = true;
                v.play();
              });
            });

        }
    },
    
    Phone__video: {
        tag:'video',
        expand: function () {
            this.domAttr('muted', 'true')
            this.domAttr('autoplay', 'true')
            this.domAttr('playsinline', 'true')
            this.domAttr('loop', 'true')
            this.domAttr('id', 'video')
            
            this.append(
                <source source="{this.text()}"></source>
            )
        }
    },
    Phone__source: {
        tag:'source',
        expand: function () {
            let src = this.param('source')
            this.domAttr('src', src)
            this.domAttr('type', 'video/mp4')
            
        }
    } 
})




Beast.decl({
    AE__highres: {
        
        expand: function fn () {

             this.append(
                <image>{this.param('src')}</image>
             )  


            
        },
        domInit: function fn() {

            

        }
    },
    AE__image: {
        
        expand: function () {
            this.tag('img')
            this.domAttr('src', this.text(''))
        }
    },

    AE__eye: {
        
        expand: function () {
            this.tag('img')
            this.domAttr('src', this.text(''))
        }
    },

    ae__aeimg: {
        
        expand: function () {
            this.tag('img')
            this.domAttr('src', this.text(''))
        }
    },
    
})



Beast.decl({
    App: {
        tag:'body',
        mod: {
            platform: '',
            device: ''
        },
        expand: function fn () {

            this.inherited(fn)

            if (MissEvent.mobile) {
                this.mix('mobile')
            }

            if (MissEvent.android) {
                this.mix('android')
            }

            if (MissEvent.ios) {
                this.mix('ios')
            }



            
        },
        domInit: function fn() {

            // Text animation for phone, email, and X links
            const linkElements = document.querySelectorAll('.cols__text_phone a, .cols__text_email a, .cols__text_x a')
            console.log('linkElements', linkElements)
            
            linkElements.forEach(element => {
                const originalText = element.textContent
                let hoverText = ''
                let originalHref = ''
                
                // Set hover text based on parent element class
                const parentElement = element.closest('.cols__text_phone, .cols__text_email, .cols__text_x')
                
                if (parentElement.classList.contains('cols__text_phone')) {
                    hoverText = '+1 833 359 6777'
                    originalHref = 'tel:+1 833 359 6777'
                } else if (parentElement.classList.contains('cols__text_email')) {
                    hoverText = 'a@ark.studio'
                    originalHref = 'mailto:a@ark.studio'
                } else if (parentElement.classList.contains('cols__text_x')) {
                    hoverText = '@ARKconclave'
                    originalHref = 'http://x.com/arkconclave'
                }
                
                // Each element gets its own animation state
                element.isAnimating = false
                element.animationInterval = null
                
                element.style.cursor = 'pointer'
                
                // Store original link
                element.originalHref = element.href
                
                element.addEventListener('mouseenter', () => {
                    if (element.animationInterval) {
                        clearInterval(element.animationInterval)
                    }
                    element.isAnimating = true
                    animatePhoneText(element, originalText, hoverText)
                    
                    // Update href
                    element.href = originalHref
                })
                
                element.addEventListener('mouseleave', () => {
                    if (element.animationInterval) {
                        clearInterval(element.animationInterval)
                    }
                    element.isAnimating = true
                    animatePhoneText(element, element.textContent, originalText)
                    
                    // Restore original href
                    element.href = element.originalHref
                })
            })
            
                         function animatePhoneText(element, originalText, finalText) {
                 const randomChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
                 let swapsRemaining = 14
                 const maxLength = Math.max(originalText.length, finalText.length)
                 
                 element.classList.add('rolling-animation')
                 
                 element.animationInterval = setInterval(() => {
                     let currentDisplayText = ''
                     
                     for (let i = 0; i < maxLength; i++) {
                         if (i < swapsRemaining) {
                             const randomChar = randomChars.charAt(Math.floor(Math.random() * randomChars.length))
                             currentDisplayText += randomChar
                         } else if (i < finalText.length) {
                             currentDisplayText += finalText[i]
                         }
                     }
                     
                     element.textContent = currentDisplayText
                     swapsRemaining--
                     
                     if (swapsRemaining <= 0) {
                         clearInterval(element.animationInterval)
                         element.textContent = finalText
                         element.classList.remove('rolling-animation')
                         element.isAnimating = false
                         
                         // If we're returning to original text, reset cursor
                         if (finalText === originalText) {
                             element.style.cursor = 'pointer'
                         }
                     }
                 }, 20)
             }

            // Menu text hover animation - same rolling effect but text doesn't change
            const menuTextElements = document.querySelectorAll('.Menu__text')
            
            menuTextElements.forEach(element => {
                element.isAnimating = false
                element.animationInterval = null
                
                // Store original font properties to prevent jumping
                const originalFontFamily = window.getComputedStyle(element).fontFamily
                const originalFontSize = window.getComputedStyle(element).fontSize
                const originalFontWeight = window.getComputedStyle(element).fontWeight
                
                element.addEventListener('mouseenter', () => {
                    if (element.isAnimating) return
                    
                    const originalText = element.textContent
                    const randomChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
                    let swapsRemaining = 20  // Longer animation
                    
                    element.isAnimating = true
                    element.classList.add('rolling-animation')
                    
                    // Preserve original font properties during animation
                    element.style.fontFamily = originalFontFamily
                    element.style.fontSize = originalFontSize
                    element.style.fontWeight = originalFontWeight
                    
                    // Ensure enough width to prevent line wrapping
                    const originalWidth = element.offsetWidth
                    const extraWidth = Math.max(20, originalWidth * 0.2) // Add 20% or minimum 20px
                    element.style.width = (originalWidth + extraWidth) + 'px'
                    element.style.display = 'inline-block'
                    element.style.whiteSpace = 'nowrap'
                    
                    element.animationInterval = setInterval(() => {
                        let currentDisplayText = ''
                        
                        for (let i = 0; i < originalText.length; i++) {
                            if (i < swapsRemaining) {
                                const randomChar = randomChars.charAt(Math.floor(Math.random() * randomChars.length))
                                currentDisplayText += randomChar
                            } else {
                                currentDisplayText += originalText[i]
                            }
                        }
                        
                        element.textContent = currentDisplayText
                        swapsRemaining--
                        
                        if (swapsRemaining <= 0) {
                            clearInterval(element.animationInterval)
                            element.textContent = originalText
                            element.classList.remove('rolling-animation')
                            element.isAnimating = false
                            
                            // Restore original styles
                            element.style.fontFamily = ''
                            element.style.fontSize = ''
                            element.style.fontWeight = ''
                            element.style.width = ''
                            element.style.display = ''
                            element.style.whiteSpace = ''
                        }
                    }, 40)  // Slower interval for longer effect
                })
            })

            // Data__jp and Data__ch letter-by-letter rolling animation on page load and repeating
            const dataJpElements = document.querySelectorAll('.Data__jp:not(.Data__jp_Hide)')
            const dataChElements = document.querySelectorAll('.Data__ch')
            const allTextElements = [...dataJpElements, ...dataChElements]
            
            allTextElements.forEach(element => {
                const originalText = element.textContent
                const isJapanese = element.classList.contains('Data__jp')
                const randomChars = isJapanese ? 
                    'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン' :
                    '信頼安全技術開発软件程序代码数据系统网络服务器客户端界面设计测试部署维护更新版本管理'
                
                // Split text into individual letters
                element.innerHTML = ''
                const letterSpans = []
                
                for (let i = 0; i < originalText.length; i++) {
                    const span = document.createElement('span')
                    span.textContent = originalText[i]
                    span.style.display = 'inline-block'
                    
                    span.style.width = 'auto'
                    element.appendChild(span)
                    letterSpans.push(span)
                    
                    // Measure the width of the original character and lock it
                    setTimeout(() => {
                        const charWidth = span.offsetWidth
                        span.style.width = charWidth + 'px'
                        span.style.textAlign = 'center'
                    }, 10)
                }
                
                // Function to animate all letters
                function animateLetters() {
                    letterSpans.forEach((span, index) => {
                        const targetLetter = originalText[index]
                        let rollCount = 0
                        const maxRolls = 6 + Math.floor(Math.random() * 4) // 6-9 rolls per letter
                        
                        setTimeout(() => {
                            span.classList.add('rolling-animation')
                            
                            const letterInterval = setInterval(() => {
                                if (rollCount < maxRolls) {
                                    // Show random character
                                    const randomChar = randomChars.charAt(Math.floor(Math.random() * randomChars.length))
                                    span.textContent = randomChar
                                    rollCount++
                                } else {
                                    // Show final character
                                    span.textContent = targetLetter
                                    span.classList.remove('rolling-animation')
                                    clearInterval(letterInterval)
                                }
                            }, 80) // 80ms per roll
                            
                        }, index * 100) // 100ms delay between each letter
                    })
                }
                
                // Function to schedule next animation
                function scheduleNextAnimation() {
                    const randomDelay = 2000 + Math.random() * 2000 // 2-4 seconds
                    setTimeout(() => {
                        animateLetters()
                        scheduleNextAnimation() // Schedule the next one
                    }, randomDelay)
                }
                
                // Start initial animation
                animateLetters()
                
                // Schedule repeating animations after initial completes
                // Wait for initial animation to finish (longest possible: 4 letters * 100ms + 9 rolls * 80ms = 1120ms)
                setTimeout(() => {
                    scheduleNextAnimation()
                }, 1500) // 1.5 seconds buffer
            })

            // Action elements shuffling animation
            const actionElements = document.querySelectorAll('.Action, .Footer__action, .Button_Type_Action')
            
            actionElements.forEach(element => {
                element.isAnimating = false
                element.animationInterval = null
                element.originalText = element.textContent // Store original text
                
                // Store original font properties to prevent jumping
                const originalFontFamily = window.getComputedStyle(element).fontFamily
                const originalFontSize = window.getComputedStyle(element).fontSize
                const originalFontWeight = window.getComputedStyle(element).fontWeight
                
                element.addEventListener('mouseenter', () => {
                    if (element.isAnimating) return
                    
                    const originalText = element.originalText
                    const randomChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
                    let swapsRemaining = originalText.length + 8  // Animation length based on text length
                    
                    element.isAnimating = true
                    element.classList.add('rolling-animation')
                    
                    // Preserve original font properties during animation
                    element.style.fontFamily = originalFontFamily
                    element.style.fontSize = originalFontSize
                    element.style.fontWeight = originalFontWeight
                    
                    // Ensure stable width during animation
                    const originalWidth = element.offsetWidth
                    const originalHeight = element.offsetHeight
                    const isActionElement = element.classList.contains('Action')
                    
                    // Lock the exact width and height to prevent any changes
                    element.style.width = originalWidth + 'px'
                    element.style.height = originalHeight + 'px'
                    element.style.display = isActionElement ? 'flex' : 'inline-flex'
                    element.style.whiteSpace = 'nowrap'
                    element.style.overflow = 'hidden'
                    element.style.textAlign = 'center'
                    
                    // For Action elements, also lock the specific positioning styles
                    if (isActionElement) {
                        element.style.alignItems = 'center'
                        element.style.justifyContent = 'center'
                        element.style.minWidth = originalWidth + 'px'
                        element.style.maxWidth = originalWidth + 'px'
                    }
                    
                    element.animationInterval = setInterval(() => {
                        let currentDisplayText = ''
                        
                        for (let i = 0; i < originalText.length; i++) {
                            if (i >= originalText.length - swapsRemaining) {
                                // Characters that are still random
                                const randomChar = randomChars.charAt(Math.floor(Math.random() * randomChars.length))
                                currentDisplayText += randomChar
                            } else {
                                // Characters that have resolved to final
                                currentDisplayText += originalText[i]
                            }
                        }
                        
                        element.textContent = currentDisplayText
                        swapsRemaining--
                        
                        if (swapsRemaining <= 0) {
                            clearInterval(element.animationInterval)
                            element.textContent = originalText
                            element.classList.remove('rolling-animation')
                            element.isAnimating = false
                            
                            // Reset styles
                            element.style.width = ''
                            element.style.height = ''
                            element.style.display = ''
                            element.style.whiteSpace = ''
                            element.style.overflow = ''
                            element.style.textAlign = ''
                            element.style.alignItems = ''
                            element.style.justifyContent = ''
                            element.style.minWidth = ''
                            element.style.maxWidth = ''
                            element.style.fontFamily = ''
                            element.style.fontSize = ''
                            element.style.fontWeight = ''
                        }
                    }, 30)
                })
                
                element.addEventListener('mouseleave', () => {
                    if (element.animationInterval) {
                        clearInterval(element.animationInterval)
                        element.textContent = element.originalText // Restore original text
                        element.classList.remove('rolling-animation')
                        element.isAnimating = false
                        
                        // Reset styles
                        element.style.width = ''
                        element.style.height = ''
                        element.style.display = ''
                        element.style.whiteSpace = ''
                        element.style.overflow = ''
                        element.style.textAlign = ''
                        element.style.alignItems = ''
                        element.style.justifyContent = ''
                        element.style.minWidth = ''
                        element.style.maxWidth = ''
                        element.style.fontFamily = ''
                        element.style.fontSize = ''
                        element.style.fontWeight = ''
                    }
                })
            })

            // Parallax scrolling for .Data and .Logo elements
            const parallaxElements = document.querySelectorAll('.Data, .Logo')
            let ticking = false
            
            function updateParallax() {
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop
                
                parallaxElements.forEach(element => {
                    // Move elements at 70% of normal scroll speed (slower)
                    // This creates a lag effect in both directions (up and down)
                    const parallaxSpeed = 0.8
                    const yPos = -(scrollTop * (1 - parallaxSpeed))
                    
                    // Apply transform with smooth rendering optimization
                    element.style.transform = `translate3d(0, ${yPos}px, 0)`
                    element.style.willChange = 'transform'
                })
                
                ticking = false
            }
            
            function requestParallaxUpdate() {
                if (!ticking) {
                    requestAnimationFrame(updateParallax)
                    ticking = true
                }
            }
            
            // Listen for scroll events
            window.addEventListener('scroll', requestParallaxUpdate, { passive: true })
            
            // Initial positioning
            updateParallax()

            // Text__item fade-in with character animation on page load
            const textItems = document.querySelectorAll('.Text__item')
            console.log('Found text items:', textItems.length) // Debug log
            
            textItems.forEach((element, index) => {
                console.log(`Text item ${index}: "${element.textContent.trim()}"`) // Debug log
                
                // Start animation after a delay based on index
                setTimeout(() => {
                    // Simple fade in and unblur
                    element.classList.add('Text__item_loaded')
                    console.log(`Text item ${index} fade + unblur complete`) // Debug log
                    
                }, index * 1000) // 1 second delay between each item
            })

            // Services__item scroll-triggered fade/unblur animation
            const servicesItems = document.querySelectorAll('.Services__item')
            console.log('Found services items:', servicesItems.length) // Debug log
            
            if (servicesItems.length > 0) {
                const observerOptions = {
                    root: null,
                    rootMargin: '-20% 0px -20% 0px', // Trigger when 20% into viewport
                    threshold: 0.3
                }
                
                const servicesObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            // Reset and start animation when entering viewport
                            if (!entry.target.classList.contains('Services__item_loaded')) {
                                let animatedItemsCount = 0
                                
                                // Reset all services items first
                                servicesItems.forEach(item => {
                                    item.classList.remove('Services__item_loaded')
                                })
                                
                                // Animate all services items in sequence
                                servicesItems.forEach((item, index) => {
                                    setTimeout(() => {
                                        item.classList.add('Services__item_loaded')
                                        
                                        // Animate the digit (::before element content) after fade-in starts
                                        setTimeout(() => {
                                            animateServiceDigit(item, index + 1)
                                        }, 200) // Start digit animation 200ms after fade begins
                                        
                                        console.log('Services item animated:', index) // Debug log
                                    }, index * 200) // 200ms delay between each item
                                })
                            }
                        } else {
                            // Reset when leaving viewport (scrolling away)
                            entry.target.classList.remove('Services__item_loaded')
                        }
                    })
                }, observerOptions)
                
                // Function to animate the digit in ::before element
                function animateServiceDigit(element, finalDigit) {
                    const randomChars = '0123456789'
                    let swapsRemaining = 6 // Short animation - 6 swaps
                    const digitStr = finalDigit.toString()
                    
                    // Create a temporary span to hold the animated digit
                    const digitSpan = document.createElement('span')
                    digitSpan.style.cssText = `
                        position: absolute;
                        top: 0;
                        left: 0;
                        color: #00f;
                        font-size: 4vw;
                        line-height: 4vw;
                        display: block;
                        z-index: 10;
                    `
                    
                    // Hide the original ::before content during animation
                    element.style.position = 'relative'
                    element.appendChild(digitSpan)
                    
                    const animationInterval = setInterval(() => {
                        if (swapsRemaining > 0) {
                            // Show random digit
                            const randomChar = randomChars.charAt(Math.floor(Math.random() * randomChars.length))
                            digitSpan.textContent = randomChar
                            swapsRemaining--
                        } else {
                            // Animation complete - show final digit and cleanup
                            digitSpan.textContent = digitStr
                            clearInterval(animationInterval)
                            
                            // Remove temporary span after a brief moment
                            setTimeout(() => {
                                if (digitSpan.parentNode) {
                                    digitSpan.parentNode.removeChild(digitSpan)
                                }
                            }, 100)
                        }
                    }, 80) // 80ms between swaps for quick animation
                }
                
                // Observe all services items
                servicesItems.forEach(item => {
                    servicesObserver.observe(item)
                })
            }
            
            // Card scroll-triggered fade/unblur animation
            const cardItems = document.querySelectorAll('.Card')
            console.log('Found card items:', cardItems.length) // Debug log
            
            if (cardItems.length > 0) {
                const cardObserverOptions = {
                    root: null,
                    rootMargin: '0px 0px 0px 0px', // No margin - trigger exactly when entering/leaving
                    threshold: 0.1 // Very small threshold - almost completely out of view
                }
                
                let lastScrollY = window.scrollY
                
                const cardObserver = new IntersectionObserver((entries) => {
                    const currentScrollY = window.scrollY
                    const scrollingUp = currentScrollY < lastScrollY
                    lastScrollY = currentScrollY
                    
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            // Card is visible - animate if not already loaded
                            if (!entry.target.classList.contains('Card_loaded')) {
                                // Reset all cards first
                                cardItems.forEach(card => {
                                    card.classList.remove('Card_loaded')
                                })
                                
                                // Animate all cards in sequence
                                cardItems.forEach((card, index) => {
                                    setTimeout(() => {
                                        card.classList.add('Card_loaded')
                                        console.log('Card animated:', index) // Debug log
                                    }, index * 150) // 150ms delay between each card
                                })
                            }
                        } else {
                            // Card is NOT visible
                            // Only reset when scrolling UP and card is out of viewport
                            if (scrollingUp) {
                                entry.target.classList.remove('Card_loaded')
                                console.log('Card reset - scrolled up and card no longer visible') // Debug log
                            }
                            // Don't reset when scrolling down (card may be above viewport)
                        }
                    })
                }, cardObserverOptions)
                
                // Observe all card items
                cardItems.forEach(card => {
                    cardObserver.observe(card)
                })
            }
            
            // Reviews dimming when footer comes into view
            const reviewsElement = document.querySelector('.Reviews')
            const footerElement = document.querySelector('.Footer')
            console.log('Found reviews element:', !!reviewsElement) // Debug log
            console.log('Found footer element:', !!footerElement) // Debug log
            
            if (reviewsElement && footerElement) {
                const footerObserverOptions = {
                    root: null,
                    rootMargin: '0px 0px 0px 0px', // Trigger when footer starts entering viewport
                    threshold: 0.4 // Trigger when 40% of footer is visible
                }
                
                const footerObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            // Footer is entering viewport - dim reviews
                            reviewsElement.classList.add('Reviews_dimmed')
                            console.log('Reviews dimmed - footer in view') // Debug log
                        } else {
                            // Footer is leaving viewport - restore reviews
                            reviewsElement.classList.remove('Reviews_dimmed')
                            console.log('Reviews restored - footer out of view') // Debug log
                        }
                    })
                }, footerObserverOptions)
                
                // Observe the footer
                footerObserver.observe(footerElement)
            }
            
            // Fallback: ensure all text items are visible after 5 seconds
            setTimeout(() => {
                textItems.forEach(element => {
                    if (!element.classList.contains('Text__item_loaded')) {
                        console.log('Fallback: showing text item') // Debug log
                        element.classList.add('Text__item_loaded')
                    }
                })
            }, 5000)

            // Footer__jp and Footer__ch letter-by-letter rolling animation - same as Data elements
            const footerJpElements = document.querySelectorAll('.Footer__jp')
            const footerChElements = document.querySelectorAll('.Footer__ch:not(.Footer__ch_Hide)')
            const allFooterTextElements = [...footerJpElements, ...footerChElements]
            
            allFooterTextElements.forEach(element => {
                const originalText = element.textContent
                const isJapanese = element.classList.contains('Footer__jp')
                const randomChars = isJapanese ? 
                    'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン' :
                    '信頼安全技術開発软件程序代码数据系统网络服务器客户端界面设计测试部署维护更新版本管理'
                
                // Split text into individual letters
                element.innerHTML = ''
                const letterSpans = []
                
                for (let i = 0; i < originalText.length; i++) {
                    const span = document.createElement('span')
                    span.textContent = originalText[i]
                    span.style.display = 'inline-block'
                    
                    span.style.width = 'auto'
                    element.appendChild(span)
                    letterSpans.push(span)
                    
                    // Measure the width of the original character and lock it
                    setTimeout(() => {
                        const charWidth = span.offsetWidth
                        span.style.width = charWidth + 'px'
                        span.style.textAlign = 'center'
                    }, 10)
                }
                
                // Function to animate all letters
                function animateLetters() {
                    letterSpans.forEach((span, index) => {
                        const targetLetter = originalText[index]
                        let rollCount = 0
                        const maxRolls = 6 + Math.floor(Math.random() * 4) // 6-9 rolls per letter
                        
                        setTimeout(() => {
                            span.classList.add('rolling-animation')
                            
                            const letterInterval = setInterval(() => {
                                if (rollCount < maxRolls) {
                                    // Show random character
                                    const randomChar = randomChars.charAt(Math.floor(Math.random() * randomChars.length))
                                    span.textContent = randomChar
                                    rollCount++
                                } else {
                                    // Show final character
                                    span.textContent = targetLetter
                                    span.classList.remove('rolling-animation')
                                    clearInterval(letterInterval)
                                }
                            }, 80) // 80ms per roll
                            
                        }, index * 100) // 100ms delay between each letter
                    })
                }
                
                // Function to schedule next animation
                function scheduleNextFooterAnimation() {
                    const randomDelay = 2000 + Math.random() * 2000 // 2-4 seconds
                    setTimeout(() => {
                        animateLetters()
                        scheduleNextFooterAnimation() // Schedule the next one
                    }, randomDelay)
                }
                
                // Start initial animation
                animateLetters()
                
                // Schedule repeating animations after initial completes
                // Wait for initial animation to finish (longest possible: 4 letters * 100ms + 9 rolls * 80ms = 1120ms)
                setTimeout(() => {
                    scheduleNextFooterAnimation()
                }, 1500) // 1.5 seconds buffer
            })

            // PathOfAwakening scroll-based blur system for headline, text, and cast
            const pathOfAwakeningHeadline = document.querySelector('.PathOfAwakening__headline');
            const pathOfAwakeningText = document.querySelector('.PathOfAwakening__text');
            const pathOfAwakeningCast = document.querySelector('.PathOfAwakening__cast');
            
            if (pathOfAwakeningHeadline) {
                // Fade in and un-blur on page load for headline
                setTimeout(() => {
                    pathOfAwakeningHeadline.classList.add('PathOfAwakening__headline_loaded');
                }, 300); // Small delay for dramatic effect
                
                function updateScrollBlurEffects() {
                    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                    const windowHeight = window.innerHeight;
                    
                    // Function to calculate blur based on element position
                    function calculateElementBlur(element, initialBlur = 3, maxBlur = 25, focusZone = 200) {
                        if (!element) return;
                        
                        const rect = element.getBoundingClientRect();
                        const elementTop = rect.top;
                        const elementHeight = rect.height;
                        const elementCenter = elementTop + elementHeight / 2;
                        
                        // Distance from element center to screen center
                        const screenCenter = windowHeight / 2;
                        const distanceFromCenter = Math.abs(elementCenter - screenCenter);
                        
                        let blurAmount;
                        
                        if (distanceFromCenter <= focusZone) {
                            // In focus zone - unblur (clear)
                            blurAmount = 0;
                        } else {
                            // Out of focus zone - blur based on distance
                            const blurProgress = Math.min(1, (distanceFromCenter - focusZone) / (windowHeight / 2));
                            blurAmount = initialBlur + (blurProgress * (maxBlur - initialBlur));
                        }
                        
                        element.style.filter = `blur(${blurAmount}px)`;
                    }
                    
                    // Apply blur effects to headline and cast only
                    if (pathOfAwakeningHeadline.classList.contains('PathOfAwakening__headline_loaded')) {
                        calculateElementBlur(pathOfAwakeningHeadline, 3, 25, 150);
                        pathOfAwakeningHeadline.style.opacity = '1'; // Keep visible
                    }
                    
                    calculateElementBlur(pathOfAwakeningCast, 3, 20, 180);
                }
                
                // Add scroll event listener
                window.addEventListener('scroll', updateScrollBlurEffects);
                
                // Initial call to set blur states
                updateScrollBlurEffects();
                
                // Sequential word appearance for PathOfAwakening text triggered by scroll
                const wordOne = document.querySelector('.PathOfAwakening__word_one');
                const wordTwo = document.querySelector('.PathOfAwakening__word_two');
                const wordThree = document.querySelector('.PathOfAwakening__word_three');
                const wordFour = document.querySelector('.PathOfAwakening__word_four');
                
                if (wordOne || wordTwo || wordThree || wordFour) {
                    let wordOneShown = false;
                    let wordTwoShown = false;
                    let wordThreeShown = false;
                    let wordFourShown = false;
                    
                    function checkWordAppearance() {
                        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                        
                        // Word One: fade in from 200px to 300px
                        if (wordOne) {
                            if (scrollTop <= 200) {
                                wordOne.style.opacity = '0';
                                wordOne.style.transform = 'translateY(20px)';
                                wordOneShown = false;
                            } else if (scrollTop > 200 && scrollTop <= 300) {
                                const progress = (scrollTop - 200) / 100; // 0 to 1
                                wordOne.style.opacity = progress;
                                wordOne.style.transform = `translateY(${20 - (progress * 20)}px)`;
                                wordOneShown = true;
                            } else if (scrollTop > 300) {
                                wordOne.style.opacity = '1';
                                wordOne.style.transform = 'translateY(0px)';
                                wordOneShown = true;
                            }
                        }
                        
                        // Word Two: fade in from 500px to 600px (requires word one)
                        if (wordTwo && wordOneShown) {
                            if (scrollTop <= 500) {
                                wordTwo.style.opacity = '0';
                                wordTwo.style.transform = 'translateY(20px)';
                                wordTwoShown = false;
                            } else if (scrollTop > 500 && scrollTop <= 600) {
                                const progress = (scrollTop - 500) / 100; // 0 to 1
                                wordTwo.style.opacity = progress;
                                wordTwo.style.transform = `translateY(${20 - (progress * 20)}px)`;
                                wordTwoShown = true;
                            } else if (scrollTop > 600) {
                                wordTwo.style.opacity = '1';
                                wordTwo.style.transform = 'translateY(0px)';
                                wordTwoShown = true;
                            }
                        }
                        
                        // Word Three: fade in from 800px to 900px (requires word two)
                        if (wordThree && wordTwoShown) {
                            if (scrollTop <= 800) {
                                wordThree.style.opacity = '0';
                                wordThree.style.transform = 'translateY(20px)';
                                wordThreeShown = false;
                            } else if (scrollTop > 800 && scrollTop <= 900) {
                                const progress = (scrollTop - 800) / 100; // 0 to 1
                                wordThree.style.opacity = progress;
                                wordThree.style.transform = `translateY(${20 - (progress * 20)}px)`;
                                wordThreeShown = true;
                            } else if (scrollTop > 900) {
                                wordThree.style.opacity = '1';
                                wordThree.style.transform = 'translateY(0px)';
                                wordThreeShown = true;
                            }
                        }
                        
                        // Word Four: fade in from 1100px to 1200px (requires word three)
                        if (wordFour && wordThreeShown) {
                            if (scrollTop <= 1100) {
                                wordFour.style.opacity = '0';
                                wordFour.style.transform = 'translateY(20px)';
                                wordFourShown = false;
                            } else if (scrollTop > 1100 && scrollTop <= 1200) {
                                const progress = (scrollTop - 1100) / 100; // 0 to 1
                                wordFour.style.opacity = progress;
                                wordFour.style.transform = `translateY(${20 - (progress * 20)}px)`;
                                wordFourShown = true;
                            } else if (scrollTop > 1200) {
                                wordFour.style.opacity = '1';
                                wordFour.style.transform = 'translateY(0px)';
                                wordFourShown = true;
                            }
                        }
                        
                        // Words One and Two: blur from 1000px to 1100px
                        if (wordOne && wordOneShown && wordTwo && wordTwoShown) {
                            if (scrollTop <= 1000) {
                                wordOne.style.filter = 'blur(0px)';
                                wordTwo.style.filter = 'blur(0px)';
                            } else if (scrollTop > 1000 && scrollTop <= 1100) {
                                const blurProgress = (scrollTop - 1000) / 100; // 0 to 1
                                const blurAmount = blurProgress * 8; // 0 to 8px
                                const opacityAmount = 1 - (blurProgress * 0.4); // 1 to 0.6
                                wordOne.style.filter = `blur(${blurAmount}px)`;
                                wordOne.style.opacity = opacityAmount;
                                wordTwo.style.filter = `blur(${blurAmount}px)`;
                                wordTwo.style.opacity = opacityAmount;
                            } else if (scrollTop > 1100) {
                                wordOne.style.filter = 'blur(8px)';
                                wordOne.style.opacity = '0.6';
                                wordTwo.style.filter = 'blur(8px)';
                                wordTwo.style.opacity = '0.6';
                            }
                        }
                        
                        // Word Three: blur from 1200px to 1300px
                        if (wordThree && wordThreeShown) {
                            if (scrollTop <= 1200) {
                                wordThree.style.filter = 'blur(0px)';
                            } else if (scrollTop > 1200 && scrollTop <= 1300) {
                                const blurProgress = (scrollTop - 1200) / 100; // 0 to 1
                                const blurAmount = blurProgress * 8; // 0 to 8px
                                const opacityAmount = 1 - (blurProgress * 0.4); // 1 to 0.6
                                wordThree.style.filter = `blur(${blurAmount}px)`;
                                wordThree.style.opacity = opacityAmount;
                            } else if (scrollTop > 1300) {
                                wordThree.style.filter = 'blur(8px)';
                                wordThree.style.opacity = '0.6';
                            }
                        }
                        
                        // Word Four: blur from 1400px to 1500px
                        if (wordFour && wordFourShown) {
                            if (scrollTop <= 1400) {
                                wordFour.style.filter = 'blur(0px)';
                            } else if (scrollTop > 1400 && scrollTop <= 1500) {
                                const blurProgress = (scrollTop - 1400) / 100; // 0 to 1
                                const blurAmount = blurProgress * 8; // 0 to 8px
                                const opacityAmount = 1 - (blurProgress * 0.4); // 1 to 0.6
                                wordFour.style.filter = `blur(${blurAmount}px)`;
                                wordFour.style.opacity = opacityAmount;
                            } else if (scrollTop > 1500) {
                                wordFour.style.filter = 'blur(8px)';
                                wordFour.style.opacity = '0.6';
                            }
                        }
                    }
                    
                    // Add to existing scroll listener
                    const originalScrollHandler = window.onscroll;
                    window.addEventListener('scroll', () => {
                        checkWordAppearance();
                    });
                    
                    // Initial check
                    checkWordAppearance();
                }
            }

            // Process step background image fade-in animation
            console.log('Setting up process step animations...')
            
            // Wait for DOM to be fully loaded
            setTimeout(() => {
                const processSteps = document.querySelectorAll('.Process__step')
                const cassetteContainer = document.querySelector('.Cassette')
                
                console.log('Process steps found:', processSteps.length)
                console.log('Cassette container found:', cassetteContainer)
                
                // Initialize all process steps with opacity 0 for background images
                processSteps.forEach(step => {
                    step.style.position = 'relative'
                    step.style.setProperty('--bg-opacity', '0')
                })
                
                // Debug: log all cassette pieces
                for (let i = 1; i <= 5; i++) {
                    const piece = document.querySelector(`.Cassette_piece_${i}`)
                    console.log(`Cassette piece ${i}:`, piece)
                }
                
                let fadeAnimationTriggered = false
                
                if (processSteps.length > 0) {
                    // Get all process titles for glow effect
                    const processTitles = document.querySelectorAll('.Process__title')
                    
                    function updateProcessAnimations() {
                        const scrollTop = window.pageYOffset || document.documentElement.scrollTop
                        const windowHeight = window.innerHeight
                        
                        // Check if first process step is in trigger range
                        const firstStep = processSteps[0]
                        if (firstStep) {
                            const stepRect = firstStep.getBoundingClientRect()
                            const stepTop = stepRect.top
                            const triggerPoint = windowHeight * 0.8
                            const fadeDistance = windowHeight * 0.3 // Fade over 30% of viewport height
                            
                            if (stepTop <= triggerPoint && stepTop > triggerPoint - fadeDistance) {
                                // First step is in fade-in range - apply to all steps
                                const progress = 1 - ((stepTop - (triggerPoint - fadeDistance)) / fadeDistance)
                                const opacity = Math.max(0, Math.min(1, progress))
                                
                                processSteps.forEach(step => {
                                    step.style.setProperty('--bg-opacity', opacity.toString())
                                })
                                
                                console.log('All process steps opacity:', opacity)
                            } else if (stepTop <= triggerPoint - fadeDistance) {
                                // First step is fully visible - all backgrounds fully visible
                                processSteps.forEach(step => {
                                    step.style.setProperty('--bg-opacity', '1')
                                })
                            } else {
                                // First step hasn't entered fade range yet - all backgrounds hidden
                                processSteps.forEach(step => {
                                    step.style.setProperty('--bg-opacity', '0')
                                })
                            }
                        }
                        
                        // Check each process title for glow effect and track active step
                        let activeStepIndex = -1
                        
                        processTitles.forEach((title, index) => {
                            const rect = title.getBoundingClientRect()
                            const titleCenter = rect.top + rect.height / 2
                            const viewportCenter = windowHeight / 2
                            const glowTriggerZone = windowHeight * 0.6 // Glow when title is within 60% of viewport height
                            
                            // Calculate distance from viewport center
                            const distanceFromCenter = Math.abs(titleCenter - viewportCenter)
                            const maxDistance = glowTriggerZone / 2
                            
                            if (distanceFromCenter <= maxDistance) {
                                // Title is in glow zone - add glow class
                                title.classList.add('Process__title_glow')
                                activeStepIndex = index
                                
                                // Also make the corresponding process text fully visible
                                const processStep = title.closest('.Process__step')
                                if (processStep) {
                                    const processText = processStep.querySelector('.Process__text')
                                    if (processText) {
                                        processText.style.opacity = '1'
                                    }
                                }
                            } else {
                                // Title is out of glow zone - remove glow class
                                title.classList.remove('Process__title_glow')
                                
                                // Reset process text opacity to default
                                const processStep = title.closest('.Process__step')
                                if (processStep) {
                                    const processText = processStep.querySelector('.Process__text')
                                    if (processText) {
                                        processText.style.opacity = ''
                                    }
                                }
                            }
                        })
                        
                        // Fade previous steps based on active step
                        processSteps.forEach((step, index) => {
                            if (activeStepIndex >= 0 && index < activeStepIndex) {
                                // This is a previous step - fade it out
                                step.classList.add('Process__step_faded')
                            } else {
                                // This is current or future step - remove fade
                                step.classList.remove('Process__step_faded')
                            }
                        })
                    }
                    
                    // Add scroll event listener for process animations
                    window.addEventListener('scroll', updateProcessAnimations)
                    
                    // Initial call
                    updateProcessAnimations()
                } else {
                    console.log('Missing process steps')
                }
            }, 1000) // Wait 1 second for DOM to be ready

        }
    },
    App__live: {
        expand: function fn () {
            this.append(
                <Live>{this.get()}</Live>
            )
        },
    },
})


Beast.decl({
    R: {
        
        expand: function fn () {

            this.append('®')      



            
        },
        domInit: function fn() {

            

        }
    },
})


Beast.decl({
    Hero: {
        expand: function () {
            this.append(
                this.get('title', 'image', 'meta'),
                <Globe/>,
                <map>
                    <Link href="./world.html">  
                        <Mini-globe/>
                    </Link>
                </map>
            )
        },
    },
    Hero__image: {
        expand: function () {
            this.append('')
            this.css({
                backgroundImage: 'url('+ this.text() +')'
            })
        }
    },
    Hero__layer: {
        expand: function () {
            this.append('')
            this.css({
                backgroundImage: 'url('+ this.text() +')'
            })
        }
    },
    Hero__layer2: {
        expand: function () {
            this.append('')
            this.css({
                backgroundImage: 'url('+ this.text() +')'
            })
        }
    },
    Hero__title: {
        expand: function () {
            this.append('')
            this.css({
                backgroundImage: 'url('+ this.text() +')'
            })
        }
    }    
})


Beast.decl({
    Workcase: {
        expand: function () {
            this.append(
                
            
            )
        },
    },
    'Workcase__gallery-item': {
        expand: function () {
            this.append('')
            this.css({
                backgroundImage: 'url('+ this.text() +')'
            })
        }
    },
    
})