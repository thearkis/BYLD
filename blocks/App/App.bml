Beast.decl({
    App: {
        tag:'body',
        mod: {
            platform: '',
            device: ''
        },
        expand: function fn () {
            this.append(
                <Noise />, this.get()
            )

        },
        domInit: function fn() {



            // Add ASCII art for ARK studio
            console.log(`
          ++++++*+++++++=+==+==+=++=++=+=+======-=
        =+++++*+++*+++=+==+==+=++=++=++=+=====-=--
      =++++++++*++++++=+=+=+=+=+=+=++=+======-=---
    =+=++++++*+++++++=+=+===+=+=+++=+==+====-=----
  ==+=++++++*++*+++++=+==+=  =++=+=++=+====-=-----
===+=++++++*++*++++=+=+==    +=++++==+====-=------

MADE BY ΛRK / www.ark.studio/byld / 2025
            `);

            // Text animation for phone, email, and X links
            const linkElements = document.querySelectorAll('.cols__text_phone a, .cols__text_email a, .cols__text_x a')
            
            
            linkElements.forEach(element => {
                const originalText = element.textContent
                let hoverText = ''
                let originalHref = ''
                
                // Set hover text based on parent element class
                const parentElement = element.closest('.cols__text_phone, .cols__text_email, .cols__text_x')
                
                if (parentElement.classList.contains('cols__text_phone')) {
                    hoverText = '+1 833 359 6777'
                    originalHref = 'tel:+1 833 359 6777'
                } else if (parentElement.classList.contains('cols__text_email')) {
                    hoverText = 'a@ark.studio'
                    originalHref = 'mailto:a@ark.studio'
                } else if (parentElement.classList.contains('cols__text_x')) {
                    hoverText = '@ARKconclave'
                    originalHref = 'http://x.com/arkconclave'
                }
                
                // Each element gets its own animation state
                element.isAnimating = false
                element.animationInterval = null
                
                element.style.cursor = 'pointer'
                
                // Store original link
                element.originalHref = element.href
                
                element.addEventListener('mouseenter', () => {
                    if (element.animationInterval) {
                        clearInterval(element.animationInterval)
                    }
                    element.isAnimating = true
                    animatePhoneText(element, originalText, hoverText)
                    
                    // Update href
                    element.href = originalHref
                })
                
                element.addEventListener('mouseleave', () => {
                    if (element.animationInterval) {
                        clearInterval(element.animationInterval)
                    }
                    element.isAnimating = true
                    animatePhoneText(element, element.textContent, originalText)
                    
                    // Restore original href
                    element.href = element.originalHref
                })
            })
            
                         function animatePhoneText(element, originalText, finalText) {
                 const randomChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
                 let swapsRemaining = 14
                 const maxLength = Math.max(originalText.length, finalText.length)
                 
                 element.classList.add('rolling-animation')
                 
                 element.animationInterval = setInterval(() => {
                     let currentDisplayText = ''
                     
                     for (let i = 0; i < maxLength; i++) {
                         if (i < swapsRemaining) {
                             const randomChar = randomChars.charAt(Math.floor(Math.random() * randomChars.length))
                             currentDisplayText += randomChar
                         } else if (i < finalText.length) {
                             currentDisplayText += finalText[i]
                         }
                     }
                     
                     element.textContent = currentDisplayText
                     swapsRemaining--
                     
                     if (swapsRemaining <= 0) {
                         clearInterval(element.animationInterval)
                         element.textContent = finalText
                         element.classList.remove('rolling-animation')
                         element.isAnimating = false
                         
                         // If we're returning to original text, reset cursor
                         if (finalText === originalText) {
                             element.style.cursor = 'pointer'
                         }
                     }
                 }, 20)
             }

            // Menu text hover animation - same rolling effect but text doesn't change
            const menuTextElements = document.querySelectorAll('.Menu__text')
            
            menuTextElements.forEach(element => {
                element.isAnimating = false
                element.animationInterval = null
                
                // Store original font properties to prevent jumping
                const originalFontFamily = window.getComputedStyle(element).fontFamily
                const originalFontSize = window.getComputedStyle(element).fontSize
                const originalFontWeight = window.getComputedStyle(element).fontWeight
                
                element.addEventListener('mouseenter', () => {
                    if (element.isAnimating) return
                    
                    const originalText = element.textContent
                    const randomChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
                    let swapsRemaining = 20  // Longer animation
                    
                    element.isAnimating = true
                    element.classList.add('rolling-animation')
                    
                    // Preserve original font properties during animation
                    element.style.fontFamily = originalFontFamily
                    element.style.fontSize = originalFontSize
                    element.style.fontWeight = originalFontWeight
                    
                    // Ensure enough width to prevent line wrapping
                    const originalWidth = element.offsetWidth
                    const extraWidth = Math.max(20, originalWidth * 0.2) // Add 20% or minimum 20px
                    element.style.width = (originalWidth + extraWidth) + 'px'
                    element.style.display = 'inline-block'
                    element.style.whiteSpace = 'nowrap'
                    
                    element.animationInterval = setInterval(() => {
                        let currentDisplayText = ''
                        
                        for (let i = 0; i < originalText.length; i++) {
                            if (i < swapsRemaining) {
                                const randomChar = randomChars.charAt(Math.floor(Math.random() * randomChars.length))
                                currentDisplayText += randomChar
                            } else {
                                currentDisplayText += originalText[i]
                            }
                        }
                        
                        element.textContent = currentDisplayText
                        swapsRemaining--
                        
                        if (swapsRemaining <= 0) {
                            clearInterval(element.animationInterval)
                            element.textContent = originalText
                            element.classList.remove('rolling-animation')
                            element.isAnimating = false
                            
                            // Restore original styles
                            element.style.fontFamily = ''
                            element.style.fontSize = ''
                            element.style.fontWeight = ''
                            element.style.width = ''
                            element.style.display = ''
                            element.style.whiteSpace = ''
                        }
                    }, 40)  // Slower interval for longer effect
                })
            })

            // Data__jp and Data__ch letter-by-letter rolling animation on page load and repeating
            const dataJpElements = document.querySelectorAll('.Data__jp:not(.Data__jp_Hide)')
            const dataChElements = document.querySelectorAll('.Data__ch')
            const allTextElements = [...dataJpElements, ...dataChElements]
            
            allTextElements.forEach(element => {
                const originalText = element.textContent
                const isJapanese = element.classList.contains('Data__jp')
                const randomChars = isJapanese ? 
                    'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン' :
                    '信頼安全技術開発软件程序代码数据系统网络服务器客户端界面设计测试部署维护更新版本管理'
                
                // Split text into individual letters
                element.innerHTML = ''
                const letterSpans = []
                
                for (let i = 0; i < originalText.length; i++) {
                    const span = document.createElement('span')
                    span.textContent = originalText[i]
                    span.style.display = 'inline-block'
                    
                    span.style.width = 'auto'
                    element.appendChild(span)
                    letterSpans.push(span)
                    
                    // Measure the width of the original character and lock it
                    setTimeout(() => {
                        const charWidth = span.offsetWidth
                        span.style.width = charWidth + 'px'
                        span.style.textAlign = 'center'
                    }, 10)
                }
                
                // Function to animate all letters
                function animateLetters() {
                    letterSpans.forEach((span, index) => {
                        const targetLetter = originalText[index]
                        let rollCount = 0
                        const maxRolls = 6 + Math.floor(Math.random() * 4) // 6-9 rolls per letter
                        
                        setTimeout(() => {
                            span.classList.add('rolling-animation')
                            
                            const letterInterval = setInterval(() => {
                                if (rollCount < maxRolls) {
                                    // Show random character
                                    const randomChar = randomChars.charAt(Math.floor(Math.random() * randomChars.length))
                                    span.textContent = randomChar
                                    rollCount++
                                } else {
                                    // Show final character
                                    span.textContent = targetLetter
                                    span.classList.remove('rolling-animation')
                                    clearInterval(letterInterval)
                                }
                            }, 80) // 80ms per roll
                            
                        }, index * 100) // 100ms delay between each letter
                    })
                }
                
                // Function to schedule next animation
                function scheduleNextAnimation() {
                    const randomDelay = 2000 + Math.random() * 2000 // 2-4 seconds
                    setTimeout(() => {
                        animateLetters()
                        scheduleNextAnimation() // Schedule the next one
                    }, randomDelay)
                }
                
                // Start initial animation
                animateLetters()
                
                // Schedule repeating animations after initial completes
                // Wait for initial animation to finish (longest possible: 4 letters * 100ms + 9 rolls * 80ms = 1120ms)
                setTimeout(() => {
                    scheduleNextAnimation()
                }, 1500) // 1.5 seconds buffer
            })



            // Action elements shuffling animation
            const actionElements = document.querySelectorAll('.Action, .Footer__action, .Button_Type_Action, .CaseAction')
            
            actionElements.forEach(element => {
                element.isAnimating = false
                element.animationInterval = null
                element.originalText = element.textContent // Store original text
                
                // Store original font properties to prevent jumping
                const originalFontFamily = window.getComputedStyle(element).fontFamily
                const originalFontSize = window.getComputedStyle(element).fontSize
                const originalFontWeight = window.getComputedStyle(element).fontWeight
                
                element.addEventListener('mouseenter', () => {
                    if (element.isAnimating) return
                    
                    const originalText = element.originalText
                    const randomChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
                    let swapsRemaining = originalText.length + 8  // Animation length based on text length
                    
                    element.isAnimating = true
                    element.classList.add('rolling-animation')
                    
                    // Preserve original font properties during animation
                    element.style.fontFamily = originalFontFamily
                    element.style.fontSize = originalFontSize
                    element.style.fontWeight = originalFontWeight
                    
                    // Ensure stable width during animation
                    const originalWidth = element.offsetWidth
                    const originalHeight = element.offsetHeight
                    const isActionElement = element.classList.contains('Action')
                    const isCaseActionElement = element.classList.contains('CaseAction')
                    
                    // Store original display value
                    const originalDisplay = window.getComputedStyle(element).display
                    
                    // Lock the exact width and height to prevent any changes
                    element.style.width = originalWidth + 'px'
                    element.style.height = originalHeight + 'px'
                    element.style.minWidth = originalWidth + 'px'
                    element.style.maxWidth = originalWidth + 'px'
                    element.style.minHeight = originalHeight + 'px'
                    element.style.maxHeight = originalHeight + 'px'
                    element.style.display = originalDisplay
                    element.style.whiteSpace = 'nowrap'
                    element.style.overflow = 'hidden'
                    element.style.textAlign = 'center'
                    element.style.boxSizing = 'border-box'
                    
                    // For Action and CaseAction elements, ensure centering
                    if (isActionElement || isCaseActionElement) {
                        element.style.alignItems = 'center'
                        element.style.justifyContent = 'center'
                    }
                    
                    element.animationInterval = setInterval(() => {
                        let currentDisplayText = ''
                        
                        for (let i = 0; i < originalText.length; i++) {
                            if (i >= originalText.length - swapsRemaining) {
                                // Characters that are still random
                                const randomChar = randomChars.charAt(Math.floor(Math.random() * randomChars.length))
                                currentDisplayText += randomChar
                            } else {
                                // Characters that have resolved to final
                                currentDisplayText += originalText[i]
                            }
                        }
                        
                        element.textContent = currentDisplayText
                        swapsRemaining--
                        
                        if (swapsRemaining <= 0) {
                            clearInterval(element.animationInterval)
                            element.textContent = originalText
                            element.classList.remove('rolling-animation')
                            element.isAnimating = false
                            
                            // Reset styles
                            element.style.width = ''
                            element.style.height = ''
                            element.style.minWidth = ''
                            element.style.maxWidth = ''
                            element.style.minHeight = ''
                            element.style.maxHeight = ''
                            element.style.display = ''
                            element.style.whiteSpace = ''
                            element.style.overflow = ''
                            element.style.textAlign = ''
                            element.style.alignItems = ''
                            element.style.justifyContent = ''
                            element.style.boxSizing = ''
                            element.style.fontFamily = ''
                            element.style.fontSize = ''
                            element.style.fontWeight = ''
                        }
                    }, 30)
                })
                
                element.addEventListener('mouseleave', () => {
                    if (element.animationInterval) {
                        clearInterval(element.animationInterval)
                        element.textContent = element.originalText // Restore original text
                        element.classList.remove('rolling-animation')
                        element.isAnimating = false
                        
                        // Reset styles
                        element.style.width = ''
                        element.style.height = ''
                        element.style.minWidth = ''
                        element.style.maxWidth = ''
                        element.style.minHeight = ''
                        element.style.maxHeight = ''
                        element.style.display = ''
                        element.style.whiteSpace = ''
                        element.style.overflow = ''
                        element.style.textAlign = ''
                        element.style.alignItems = ''
                        element.style.justifyContent = ''
                        element.style.boxSizing = ''
                        element.style.fontFamily = ''
                        element.style.fontSize = ''
                        element.style.fontWeight = ''
                    }
                })
            })

            // Parallax scrolling for .Data, .Logo, .Case__head, .CaseMeta/.Divider_One, and .Case__image/.About/.Services elements with different speeds
            const dataElements = document.querySelectorAll('.Data')
            const logoElements = document.querySelectorAll('.Logo')
            const caseHeadElements = document.querySelectorAll('.Case__head')
            const caseMetaElements = document.querySelectorAll('.CaseMeta')
            const dividerOneElements = document.querySelectorAll('.header.header_top')
            const caseImageElements = document.querySelectorAll('.Case__image')
            const aboutElements = document.querySelectorAll('.case__descr')
            const servicesElements = document.querySelectorAll('.Services')
            let ticking = false
            
            function updateParallax() {
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop
                const windowHeight = window.innerHeight
                
                // Data elements - slower parallax with blur
                dataElements.forEach(element => {
                    const parallaxSpeed = 0.7 // Slower - more lag effect
                    const yPos = -(scrollTop * (1 - parallaxSpeed))
                    
                    // Calculate blur based on element position relative to viewport
                    const elementRect = element.getBoundingClientRect()
                    const elementTop = elementRect.top
                    const elementBottom = elementRect.bottom
                    
                    let blurAmount = 0
                    
                    // Blur when element approaches or exits the top of viewport
                    if (elementTop < windowHeight * 0.20 && elementBottom > 0) {
                        // Element is in upper 15% of viewport or above
                        const triggerPoint = windowHeight * 0.15
                        const distanceFromTrigger = Math.max(0, triggerPoint - elementTop)
                        const maxDistance = triggerPoint + elementRect.height
                        const exitProgress = distanceFromTrigger / maxDistance
                        blurAmount = Math.min(exitProgress * 8, 8) // Max 8px blur
                    }
                    
                    element.style.transform = `translate3d(0, ${yPos}px, 0)`
                    element.style.filter = `blur(${blurAmount}px)`
                    element.style.willChange = 'transform, filter'
                })
                
                // Logo elements - faster parallax with blur
                logoElements.forEach(element => {
                    const parallaxSpeed = 0.85 // Faster - less lag effect
                    const yPos = -(scrollTop * (1 - parallaxSpeed))
                    
                    // Calculate blur based on element position relative to viewport
                    const elementRect = element.getBoundingClientRect()
                    const elementTop = elementRect.top
                    const elementBottom = elementRect.bottom
                    
                    let blurAmount = 0
                    
                    // Blur when element approaches or exits the top of viewport
                    if (elementTop < windowHeight * 0.15 && elementBottom > 0) {
                        // Element is in upper 15% of viewport or above
                        const triggerPoint = windowHeight * 0.15
                        const distanceFromTrigger = Math.max(0, triggerPoint - elementTop)
                        const maxDistance = triggerPoint + elementRect.height
                        const exitProgress = distanceFromTrigger / maxDistance
                        blurAmount = Math.min(exitProgress * 20, 20) // Max 6px blur (less than data)
                    }
                    
                    element.style.transform = `translate3d(0, ${yPos}px, 0)`
                    element.style.filter = `blur(${blurAmount}px)`
                    element.style.willChange = 'transform, filter'
                })
                
                // Case__head elements - same speed as Data elements with blur
                caseHeadElements.forEach(element => {
                    const parallaxSpeed = 0.7 // Same as Data - slower parallax with more lag effect
                    const yPos = -(scrollTop * (1 - parallaxSpeed))
                    
                    // Calculate blur based on element position relative to viewport
                    const elementRect = element.getBoundingClientRect()
                    const elementTop = elementRect.top
                    const elementBottom = elementRect.bottom
                    
                    let blurAmount = 0
                    
                    // Blur when element approaches or exits the top of viewport
                    if (elementTop < windowHeight * 0.20 && elementBottom > 0) {
                        // Element is in upper 20% of viewport or above
                        const triggerPoint = windowHeight * 0.15
                        const distanceFromTrigger = Math.max(0, triggerPoint - elementTop)
                        const maxDistance = triggerPoint + elementRect.height
                        const exitProgress = distanceFromTrigger / maxDistance
                        blurAmount = Math.min(exitProgress * 8, 8) // Max 8px blur (same as Data)
                    }
                    
                    element.style.transform = `translate3d(0, ${yPos}px, 0)`
                    element.style.filter = `blur(${blurAmount}px)`
                    element.style.willChange = 'transform, filter'
                })
                
                // CaseMeta and Divider_One elements - different speed than Case__head, move together
                const caseMetaGroupElements = [...caseMetaElements, ...dividerOneElements]
                caseMetaGroupElements.forEach(element => {
                    const parallaxSpeed = 0.8 // Faster than Data/Case__head (0.7) - less lag effect
                    const yPos = -(scrollTop * (1 - parallaxSpeed))
                    
                    // Calculate blur based on element position relative to viewport
                    const elementRect = element.getBoundingClientRect()
                    const elementTop = elementRect.top
                    const elementBottom = elementRect.bottom
                    
                    let blurAmount = 0
                    
                    // Blur when element approaches or exits the top of viewport
                    if (elementTop < windowHeight * 0.20 && elementBottom > 0) {
                        // Element is in upper 20% of viewport or above
                        const triggerPoint = windowHeight * 0.15
                        const distanceFromTrigger = Math.max(0, triggerPoint - elementTop)
                        const maxDistance = triggerPoint + elementRect.height
                        const exitProgress = distanceFromTrigger / maxDistance
                        blurAmount = Math.min(exitProgress * 8, 8) // Max 8px blur (same as other elements)
                    }
                    
                    element.style.transform = `translate3d(0, ${yPos}px, 0)`
                    element.style.filter = `blur(${blurAmount}px)`
                    element.style.willChange = 'transform, filter'
                })
                
                // Case__image, About, and Services elements - blur only (no parallax movement)
                const caseContentElements = [...caseImageElements, ...aboutElements, ...servicesElements]
                caseContentElements.forEach(element => {
                    // Calculate blur based on element position relative to viewport
                    const elementRect = element.getBoundingClientRect()
                    const elementTop = elementRect.top
                    const elementBottom = elementRect.bottom
                    
                    let blurAmount = 0
                    
                    // Blur when element approaches or exits the top of viewport
                    if (elementTop < windowHeight * 0.20 && elementBottom > 0) {
                        // Element is in upper 20% of viewport or above
                        const triggerPoint = windowHeight * 0.15
                        const distanceFromTrigger = Math.max(0, triggerPoint - elementTop)
                        const maxDistance = triggerPoint + elementRect.height
                        const exitProgress = distanceFromTrigger / maxDistance
                        blurAmount = Math.min(exitProgress * 8, 8) // Max 8px blur (same as other elements)
                    }
                    
                    // Only apply blur, no transform/movement
                    element.style.filter = `blur(${blurAmount}px)`
                    element.style.willChange = 'filter'
                })
                
                // Handle Text__item parallax blur
                const textItems = document.querySelectorAll('.Text__item')
                textItems.forEach(element => {
                    const elementRect = element.getBoundingClientRect()
                    const elementTop = elementRect.top
                    const elementBottom = elementRect.bottom
                    
                    let blurAmount = 0
                    
                    // Blur when element approaches or exits the top of viewport
                    if (elementTop < windowHeight * 0.20 && elementBottom > 0) {
                        // Element is in upper 20% of viewport or above
                        const triggerPoint = windowHeight * 0.15
                        const distanceFromTrigger = Math.max(0, triggerPoint - elementTop)
                        const maxDistance = triggerPoint + elementRect.height
                        const exitProgress = distanceFromTrigger / maxDistance
                        blurAmount = Math.min(exitProgress * 12, 12) // Max 12px blur (medium intensity)
                    }
                    
                    element.style.filter = `blur(${blurAmount}px)`
                    element.style.willChange = 'filter'
                })
                
                ticking = false
            }
            
            function requestParallaxUpdate() {
                if (!ticking) {
                    requestAnimationFrame(updateParallax)
                    ticking = true
                }
            }
            
            // Listen for scroll events
            window.addEventListener('scroll', requestParallaxUpdate, { passive: true })
            
            // Initial positioning
            updateParallax()

            // Text__item fade-in with character animation on page load
            const textItems = document.querySelectorAll('.Text__item')
            
            
            textItems.forEach((element, index) => {
                
                
                // Start animation after a delay based on index
                setTimeout(() => {
                    // Simple fade in and unblur
                    element.classList.add('Text__item_loaded')
                    
                    
                }, index * 1000) // 1 second delay between each item
            })

            // Case__client and Case__title fade-in on page load
            const caseClientElements = document.querySelectorAll('.Case__client-card')
            const caseTitleElements = document.querySelectorAll('.Case__title')
            
            
            // Animate Case__client first
            caseClientElements.forEach((element, index) => {
                setTimeout(() => {
                    element.classList.add('Case__client-card_loaded')
                    
                }, index * 300) // 300ms delay between each client element
            })
            
            // Animate Case__title after client elements (with additional delay)
            caseTitleElements.forEach((element, index) => {
                setTimeout(() => {
                    element.classList.add('Case__title_loaded')
                    
                }, (caseClientElements.length * 300) + (index * 300) + 200) // Start after clients finish + 200ms
            })

            // CaseMeta__meta-item fade-in on page load (after Case elements)
            const caseMetaItems = document.querySelectorAll('.CaseMeta__item')
            
            
            // Calculate when Case elements will finish (minimum 800ms even if no elements)
            const caseElementsFinishTime = Math.max(
                (caseClientElements.length * 300) + (caseTitleElements.length * 300) + 400,
                800
            )
            
            
            
            // Animate CaseMeta__meta-item elements after Case elements finish
            caseMetaItems.forEach((element, index) => {
                setTimeout(() => {
                    element.classList.add('CaseMeta__item_loaded')
                    
                }, caseElementsFinishTime + (index * 200)) // Start after Case elements + 200ms delay between each
            })
            
            // Fallback: ensure all meta items are visible after 5 seconds
            setTimeout(() => {
                caseMetaItems.forEach((element, index) => {
                    if (!element.classList.contains('CaseMeta__meta-item_loaded')) {
                        
                        element.classList.add('CaseMeta__item_loaded')
                    }
                })
            }, 5000)

            // Caseresult__item fade-in on page load (after CaseMeta items finish)
            const caseresultItems = document.querySelectorAll('.Caseresult__item')
            
            
            // Calculate when CaseMeta items will finish
            const caseMetaFinishTime = caseElementsFinishTime + (caseMetaItems.length * 200) + 200
            
            
            // Animate Caseresult__item elements earlier, overlapping with CaseMeta items
            caseresultItems.forEach((element, index) => {
                const earlierStartTime = caseMetaFinishTime - 300 // Start 300ms earlier
                setTimeout(() => {
                    element.classList.add('Caseresult__item_loaded')
                    
                }, earlierStartTime + (index * 100)) // Faster sequence: 100ms delay between each
            })

            // caseresult__title and caseresult__text character swapping animation on load
            const caseresultTitleElements = document.querySelectorAll('.caseresult__title')
            const caseresultTextElements = document.querySelectorAll('.caseresult__text')
            
            const allCaseresultTextElements = [...caseresultTitleElements, ...caseresultTextElements]
            
            allCaseresultTextElements.forEach(element => {
                const text = element.textContent.trim()
                if (text.length === 0) return
                
                
                
                // Split text into individual character spans
                element.innerHTML = text.split('').map(char => '<span>' + char + '</span>').join('')
                
                const spans = element.querySelectorAll('span')
                const originalText = text.split('')
                
                function animateCaseresultLetters() {
                    
                    spans.forEach((span, index) => {
                        const delay = index * 30 // 30ms delay between letters (same as other animations)
                        setTimeout(() => {
                            let rollCount = 0
                            const maxRolls = 15 // More character swaps for longer rolling effect
                            
                            const rollInterval = setInterval(() => {
                                if (rollCount < maxRolls) {
                                    // Random character from ASCII 33-126 (visible characters)
                                    const randomChar = String.fromCharCode(33 + Math.floor(Math.random() * 94))
                                    span.textContent = randomChar
                                    rollCount++
                                } else {
                                    // Animation complete - restore original character
                                    span.textContent = originalText[index]
                                    clearInterval(rollInterval)
                                }
                            }, 50) // 50ms between character swaps (same as other animations)
                        }, delay)
                    })
                }
                
                // Determine timing based on element type
                const isTitleElement = element.classList.contains('caseresult__title')
                const isTextElement = element.classList.contains('caseresult__text')
                
                // Find which caseresult__item this element belongs to
                const parentItem = element.closest('.caseresult__item')
                if (parentItem) {
                    // Find the index of this item among all caseresult items
                    const allItems = document.querySelectorAll('.caseresult__item')
                    const itemIndex = Array.from(allItems).indexOf(parentItem)
                    
                    // Calculate when this specific item will fade in (using new earlier timing)
                    const earlierStartTime = caseMetaFinishTime - 300 // Start 300ms earlier
                    const itemFadeInTime = earlierStartTime + (itemIndex * 100) // Faster sequence: 100ms delay
                    
                    // Start character animation almost immediately with the fade-in
                    const characterAnimationDelay = isTitleElement ? 30 : 100 // Even earlier: Title first, then text with delay
                    const totalDelay = itemFadeInTime + characterAnimationDelay
                    
                    
                    setTimeout(() => {
                        
                        animateCaseresultLetters()
                    }, totalDelay)
                }
            })

            // Services__item scroll-triggered fade/unblur animation
            const servicesItems = document.querySelectorAll('.Services__item')
            
            
            if (servicesItems.length > 0) {
                const observerOptions = {
                    root: null,
                    rootMargin: '-20% 0px -20% 0px', // Trigger when 20% into viewport
                    threshold: 0.3
                }
                
                const servicesObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            // Reset and start animation when entering viewport
                            if (!entry.target.classList.contains('Services__item_loaded')) {
                                let animatedItemsCount = 0
                                
                                // Reset all services items first
                                servicesItems.forEach(item => {
                                    item.classList.remove('Services__item_loaded')
                                })
                                
                                // Animate all services items in sequence
                                servicesItems.forEach((item, index) => {
                                    setTimeout(() => {
                                        item.classList.add('Services__item_loaded')
                                        
                                        // Animate the digit (::before element content) after fade-in starts
                                        setTimeout(() => {
                                            Shuffle.animateServiceDigit(item, index + 1)
                                        }, 200) // Start digit animation 200ms after fade begins
                                        
                                        
                                    }, index * 200) // 200ms delay between each item
                                })
                            }
                        } else {
                            // Reset when leaving viewport (scrolling away)
                            entry.target.classList.remove('Services__item_loaded')
                        }
                    })
                }, observerOptions)
                

                
                // Observe all services items
                servicesItems.forEach(item => {
                    servicesObserver.observe(item)
                })
            }
            
            // Card scroll-triggered fade/unblur animation
            const cardItems = document.querySelectorAll('.Card')
            
            
            if (cardItems.length > 0) {
                const cardObserverOptions = {
                    root: null,
                    rootMargin: '0px 0px 0px 0px', // No margin - trigger exactly when entering/leaving
                    threshold: 0.1 // Very small threshold - almost completely out of view
                }
                
                let lastScrollY = window.scrollY
                
                const cardObserver = new IntersectionObserver((entries) => {
                    const currentScrollY = window.scrollY
                    const scrollingUp = currentScrollY < lastScrollY
                    lastScrollY = currentScrollY
                    
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            // Card is visible - animate if not already loaded
                            if (!entry.target.classList.contains('Card_loaded')) {
                                // Reset all cards first
                                cardItems.forEach(card => {
                                    card.classList.remove('Card_loaded')
                                })
                                
                                // Animate all cards in sequence
                                cardItems.forEach((card, index) => {
                                    setTimeout(() => {
                                        card.classList.add('Card_loaded')
                                        
                                    }, index * 150) // 150ms delay between each card
                                })
                            }
                        } else {
                            // Card is NOT visible
                            // Only reset when scrolling UP and card is out of viewport
                            if (scrollingUp) {
                                entry.target.classList.remove('Card_loaded')
                                
                            }
                            // Don't reset when scrolling down (card may be above viewport)
                        }
                    })
                }, cardObserverOptions)
                
                // Observe all card items
                cardItems.forEach(card => {
                    cardObserver.observe(card)
                })
            }
            

            // Scroll-triggered fade/unblur animation for Case__image, case__descr, case__solution, Review, and case__impact-bottom
            const scrollAnimationElements = [
                { selector: '.Case__image', className: 'Case__image_loaded' },
                { selector: '.Case__descr', className: 'Case__descr_loaded' },
                { selector: '.Case__solution', className: 'Case__solution_loaded' },
                { selector: '.Case__review', className: 'Case__review_loaded' },
                { selector: '.Case__impact-bottom', className: 'Case__impact-bottom_loaded' }
            ]
            
            scrollAnimationElements.forEach(({ selector, className }) => {
                const elements = document.querySelectorAll(selector)
                
                
                if (elements.length > 0) {
                    const observerOptions = {
                        root: null,
                        rootMargin: '0px 0px -20% 0px', // Trigger when 20% into viewport
                        threshold: 0.1
                    }
                    
                    const elementObserver = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                // Element is visible - animate
                                entry.target.classList.add(className)
                                
                            } else {
                                // Element is not visible - reset animation
                                entry.target.classList.remove(className)
                                
                            }
                        })
                    }, observerOptions)
                    
                    // Observe all elements of this type
                    elements.forEach(element => {
                        elementObserver.observe(element)
                    })
                }
            })

            // Scroll-triggered character shuffling animation for caseresult__item elements
            const scrollCaseresultItems = document.querySelectorAll('.caseresult__item')
            
            if (scrollCaseresultItems.length > 0) {
                const caseresultObserverOptions = {
                    root: null,
                    rootMargin: '0px 0px -20% 0px', // Trigger when 20% into viewport
                    threshold: 0.3
                }
                
                const caseresultObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            // caseresult__item is visible - trigger character animation
                            const item = entry.target
                            
                            // Find title and text elements within this item
                            const titleElement = item.querySelector('.caseresult__title')
                            const textElement = item.querySelector('.caseresult__text')
                            
                            // Animate title first, then text
                            if (titleElement) {
                                setTimeout(() => {
                                    animateCaseresultText(titleElement)
                                }, 100)
                            }
                            
                            if (textElement) {
                                setTimeout(() => {
                                    animateCaseresultText(textElement)
                                }, 300) // Start text animation 200ms after title
                            }
                            
                        }
                    })
                }, caseresultObserverOptions)
                
                // Function to animate caseresult text with character shuffling
                function animateCaseresultText(element) {
                    const text = element.textContent.trim()
                    if (text.length === 0) return
                    
                    // Split text into individual character spans
                    element.innerHTML = text.split('').map(char => '<span>' + char + '</span>').join('')
                    
                    const spans = element.querySelectorAll('span')
                    const originalText = text.split('')
                    
                    spans.forEach((span, index) => {
                        const delay = index * 30 // 30ms delay between letters
                        setTimeout(() => {
                            let rollCount = 0
                            const maxRolls = 15 // More character swaps for longer rolling effect
                            
                            const rollInterval = setInterval(() => {
                                if (rollCount < maxRolls) {
                                    // Random character from ASCII 33-126 (visible characters)
                                    const randomChar = String.fromCharCode(33 + Math.floor(Math.random() * 94))
                                    span.textContent = randomChar
                                    rollCount++
                                } else {
                                    // Animation complete - restore original character
                                    span.textContent = originalText[index]
                                    clearInterval(rollInterval)
                                }
                            }, 50) // 50ms between character swaps
                        }, delay)
                    })
                }
                
                // Observe all caseresult items
                scrollCaseresultItems.forEach(item => {
                    caseresultObserver.observe(item)
                })
            }

            // Reviews dimming when footer comes into view
            const reviewsElement = document.querySelector('.Reviews')
            const footerElement = document.querySelector('.Footer')
            
            
            if (reviewsElement && footerElement) {
                const footerObserverOptions = {
                    root: null,
                    rootMargin: '0px 0px 0px 0px', // Trigger when footer starts entering viewport
                    threshold: 0.4 // Trigger when 40% of footer is visible
                }
                
                const footerObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            // Footer is entering viewport - dim reviews
                            reviewsElement.classList.add('Reviews_dimmed')
                            
                        } else {
                            // Footer is leaving viewport - restore reviews
                            reviewsElement.classList.remove('Reviews_dimmed')
                            
                        }
                    })
                }, footerObserverOptions)
                
                // Observe the footer
                footerObserver.observe(footerElement)
            }
            
            // Fallback: ensure all text items are visible after 5 seconds
            setTimeout(() => {
                textItems.forEach(element => {
                    if (!element.classList.contains('Text__item_loaded')) {
                        
                        element.classList.add('Text__item_loaded')
                    }
                })
            }, 5000)

            // Footer__jp and Footer__ch letter-by-letter rolling animation - same as Data elements
            const footerJpElements = document.querySelectorAll('.Footer__jp')
            const footerChElements = document.querySelectorAll('.Footer__ch:not(.Footer__ch_Hide)')
            const allFooterTextElements = [...footerJpElements, ...footerChElements]
            
            allFooterTextElements.forEach(element => {
                const originalText = element.textContent
                const isJapanese = element.classList.contains('Footer__jp')
                const randomChars = isJapanese ? 
                    'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン' :
                    '信頼安全技術開発软件程序代码数据系统网络服务器客户端界面设计测试部署维护更新版本管理'
                
                // Split text into individual letters
                element.innerHTML = ''
                const letterSpans = []
                
                for (let i = 0; i < originalText.length; i++) {
                    const span = document.createElement('span')
                    span.textContent = originalText[i]
                    span.style.display = 'inline-block'
                    
                    span.style.width = 'auto'
                    element.appendChild(span)
                    letterSpans.push(span)
                    
                    // Measure the width of the original character and lock it
                    setTimeout(() => {
                        const charWidth = span.offsetWidth
                        span.style.width = charWidth + 'px'
                        span.style.textAlign = 'center'
                    }, 10)
                }
                
                // Function to animate all letters
                function animateLetters() {
                    letterSpans.forEach((span, index) => {
                        const targetLetter = originalText[index]
                        let rollCount = 0
                        const maxRolls = 6 + Math.floor(Math.random() * 4) // 6-9 rolls per letter
                        
                        setTimeout(() => {
                            span.classList.add('rolling-animation')
                            
                            const letterInterval = setInterval(() => {
                                if (rollCount < maxRolls) {
                                    // Show random character
                                    const randomChar = randomChars.charAt(Math.floor(Math.random() * randomChars.length))
                                    span.textContent = randomChar
                                    rollCount++
                                } else {
                                    // Show final character
                                    span.textContent = targetLetter
                                    span.classList.remove('rolling-animation')
                                    clearInterval(letterInterval)
                                }
                            }, 80) // 80ms per roll
                            
                        }, index * 100) // 100ms delay between each letter
                    })
                }
                
                // Function to schedule next animation
                function scheduleNextFooterAnimation() {
                    const randomDelay = 2000 + Math.random() * 2000 // 2-4 seconds
                    setTimeout(() => {
                        animateLetters()
                        scheduleNextFooterAnimation() // Schedule the next one
                    }, randomDelay)
                }
                
                // Start initial animation
                animateLetters()
                
                // Schedule repeating animations after initial completes
                // Wait for initial animation to finish (longest possible: 4 letters * 100ms + 9 rolls * 80ms = 1120ms)
                setTimeout(() => {
                    scheduleNextFooterAnimation()
                }, 1500) // 1.5 seconds buffer
            })

            // PathOfAwakening scroll-based blur system for headline, text, and cast
            const pathOfAwakeningHeadline = document.querySelector('.PathOfAwakening__headline');
            const pathOfAwakeningText = document.querySelector('.PathOfAwakening__text');
            const pathOfAwakeningCast = document.querySelector('.PathOfAwakening__cast');
            
            if (pathOfAwakeningHeadline) {
                // Fade in and un-blur on page load for headline
                setTimeout(() => {
                    pathOfAwakeningHeadline.classList.add('PathOfAwakening__headline_loaded');
                }, 300); // Small delay for dramatic effect
                
                function updateScrollBlurEffects() {
                    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                    const windowHeight = window.innerHeight;
                    
                    // Function to calculate blur based on element position
                    function calculateElementBlur(element, initialBlur = 3, maxBlur = 25, focusZone = 200) {
                        if (!element) return;
                        
                        const rect = element.getBoundingClientRect();
                        const elementTop = rect.top;
                        const elementHeight = rect.height;
                        const elementCenter = elementTop + elementHeight / 2;
                        
                        // Distance from element center to screen center
                        const screenCenter = windowHeight / 2;
                        const distanceFromCenter = Math.abs(elementCenter - screenCenter);
                        
                        let blurAmount;
                        
                        if (distanceFromCenter <= focusZone) {
                            // In focus zone - unblur (clear)
                            blurAmount = 0;
                        } else {
                            // Out of focus zone - blur based on distance
                            const blurProgress = Math.min(1, (distanceFromCenter - focusZone) / (windowHeight / 2));
                            blurAmount = initialBlur + (blurProgress * (maxBlur - initialBlur));
                        }
                        
                        element.style.filter = `blur(${blurAmount}px)`;
                    }
                    
                    // Apply blur effects to headline and cast only
                    if (pathOfAwakeningHeadline.classList.contains('PathOfAwakening__headline_loaded')) {
                        calculateElementBlur(pathOfAwakeningHeadline, 3, 25, 150);
                        pathOfAwakeningHeadline.style.opacity = '1'; // Keep visible
                    }
                    
                    calculateElementBlur(pathOfAwakeningCast, 3, 20, 180);
                }
                
                // Add scroll event listener
                window.addEventListener('scroll', updateScrollBlurEffects);
                
                // Initial call to set blur states
                updateScrollBlurEffects();
                
                // Sequential word appearance for PathOfAwakening text triggered by scroll
                const wordOne = document.querySelector('.PathOfAwakening__word_one');
                const wordTwo = document.querySelector('.PathOfAwakening__word_two');
                const wordThree = document.querySelector('.PathOfAwakening__word_three');
                const wordFour = document.querySelector('.PathOfAwakening__word_four');
                
                if (wordOne || wordTwo || wordThree || wordFour) {
                    let wordOneShown = false;
                    let wordTwoShown = false;
                    let wordThreeShown = false;
                    let wordFourShown = false;
                    
                    function checkWordAppearance() {
                        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                        
                        // Word One: fade in from 200px to 300px
                        if (wordOne) {
                            if (scrollTop <= 200) {
                                wordOne.style.opacity = '0';
                                wordOne.style.transform = 'translateY(20px)';
                                wordOneShown = false;
                            } else if (scrollTop > 200 && scrollTop <= 300) {
                                const progress = (scrollTop - 200) / 100; // 0 to 1
                                wordOne.style.opacity = progress;
                                wordOne.style.transform = `translateY(${20 - (progress * 20)}px)`;
                                wordOneShown = true;
                            } else if (scrollTop > 300) {
                                wordOne.style.opacity = '1';
                                wordOne.style.transform = 'translateY(0px)';
                                wordOneShown = true;
                            }
                        }
                        
                        // Word Two: fade in from 500px to 600px (requires word one)
                        if (wordTwo && wordOneShown) {
                            if (scrollTop <= 500) {
                                wordTwo.style.opacity = '0';
                                wordTwo.style.transform = 'translateY(20px)';
                                wordTwoShown = false;
                            } else if (scrollTop > 500 && scrollTop <= 600) {
                                const progress = (scrollTop - 500) / 100; // 0 to 1
                                wordTwo.style.opacity = progress;
                                wordTwo.style.transform = `translateY(${20 - (progress * 20)}px)`;
                                wordTwoShown = true;
                            } else if (scrollTop > 600) {
                                wordTwo.style.opacity = '1';
                                wordTwo.style.transform = 'translateY(0px)';
                                wordTwoShown = true;
                            }
                        }
                        
                        // Word Three: fade in from 800px to 900px (requires word two)
                        if (wordThree && wordTwoShown) {
                            if (scrollTop <= 800) {
                                wordThree.style.opacity = '0';
                                wordThree.style.transform = 'translateY(20px)';
                                wordThreeShown = false;
                            } else if (scrollTop > 800 && scrollTop <= 900) {
                                const progress = (scrollTop - 800) / 100; // 0 to 1
                                wordThree.style.opacity = progress;
                                wordThree.style.transform = `translateY(${20 - (progress * 20)}px)`;
                                wordThreeShown = true;
                            } else if (scrollTop > 900) {
                                wordThree.style.opacity = '1';
                                wordThree.style.transform = 'translateY(0px)';
                                wordThreeShown = true;
                            }
                        }
                        
                        // Word Four: fade in from 1100px to 1200px (requires word three)
                        if (wordFour && wordThreeShown) {
                            if (scrollTop <= 1100) {
                                wordFour.style.opacity = '0';
                                wordFour.style.transform = 'translateY(20px)';
                                wordFourShown = false;
                            } else if (scrollTop > 1100 && scrollTop <= 1200) {
                                const progress = (scrollTop - 1100) / 100; // 0 to 1
                                wordFour.style.opacity = progress;
                                wordFour.style.transform = `translateY(${20 - (progress * 20)}px)`;
                                wordFourShown = true;
                            } else if (scrollTop > 1200) {
                                wordFour.style.opacity = '1';
                                wordFour.style.transform = 'translateY(0px)';
                                wordFourShown = true;
                            }
                        }
                        
                        // Words One and Two: blur from 1000px to 1100px
                        if (wordOne && wordOneShown && wordTwo && wordTwoShown) {
                            if (scrollTop <= 1000) {
                                wordOne.style.filter = 'blur(0px)';
                                wordTwo.style.filter = 'blur(0px)';
                            } else if (scrollTop > 1000 && scrollTop <= 1100) {
                                const blurProgress = (scrollTop - 1000) / 100; // 0 to 1
                                const blurAmount = blurProgress * 8; // 0 to 8px
                                const opacityAmount = 1 - (blurProgress * 0.4); // 1 to 0.6
                                wordOne.style.filter = `blur(${blurAmount}px)`;
                                wordOne.style.opacity = opacityAmount;
                                wordTwo.style.filter = `blur(${blurAmount}px)`;
                                wordTwo.style.opacity = opacityAmount;
                            } else if (scrollTop > 1100) {
                                wordOne.style.filter = 'blur(8px)';
                                wordOne.style.opacity = '0.6';
                                wordTwo.style.filter = 'blur(8px)';
                                wordTwo.style.opacity = '0.6';
                            }
                        }
                        
                        // Word Three: blur from 1200px to 1300px
                        if (wordThree && wordThreeShown) {
                            if (scrollTop <= 1200) {
                                wordThree.style.filter = 'blur(0px)';
                            } else if (scrollTop > 1200 && scrollTop <= 1300) {
                                const blurProgress = (scrollTop - 1200) / 100; // 0 to 1
                                const blurAmount = blurProgress * 8; // 0 to 8px
                                const opacityAmount = 1 - (blurProgress * 0.4); // 1 to 0.6
                                wordThree.style.filter = `blur(${blurAmount}px)`;
                                wordThree.style.opacity = opacityAmount;
                            } else if (scrollTop > 1300) {
                                wordThree.style.filter = 'blur(8px)';
                                wordThree.style.opacity = '0.6';
                            }
                        }
                        
                        // Word Four: blur from 1400px to 1500px
                        if (wordFour && wordFourShown) {
                            if (scrollTop <= 1400) {
                                wordFour.style.filter = 'blur(0px)';
                            } else if (scrollTop > 1400 && scrollTop <= 1500) {
                                const blurProgress = (scrollTop - 1400) / 100; // 0 to 1
                                const blurAmount = blurProgress * 8; // 0 to 8px
                                const opacityAmount = 1 - (blurProgress * 0.4); // 1 to 0.6
                                wordFour.style.filter = `blur(${blurAmount}px)`;
                                wordFour.style.opacity = opacityAmount;
                            } else if (scrollTop > 1500) {
                                wordFour.style.filter = 'blur(8px)';
                                wordFour.style.opacity = '0.6';
                            }
                        }
                    }
                    
                    // Add to existing scroll listener
                    const originalScrollHandler = window.onscroll;
                    window.addEventListener('scroll', () => {
                        checkWordAppearance();
                    });
                    
                    // Initial check
                    checkWordAppearance();
                }
            }

            // Cassette pieces scroll detection for fixed positioning
            const cassettePieces = []
            let atLastPiece = false
            
            // Get all cassette pieces
            for (let i = 1; i <= 5; i++) {
                const piece = document.querySelector(`.Cassette_piece_${i}`)
                if (piece) {
                    cassettePieces.push({
                        element: piece,
                        index: i,
                        isFixed: false,
                        triggerPoint: piece.getBoundingClientRect().top + window.scrollY
                    })
                    console.log(`Found cassette piece ${i}`)
                }
            }
            
            if (cassettePieces.length > 0) {
                console.log(`Found ${cassettePieces.length} cassette pieces, setting up scroll listener`)
                
                function checkCassettePositions() {
                    const scrollY = window.scrollY
                    const windowHeight = window.innerHeight
                    
                    // Check if we've reached the last piece (piece 5)
                    const lastPiece = cassettePieces[cassettePieces.length - 1]
                    const reachedLastPiece = scrollY >= lastPiece.triggerPoint - 100
                    
                    if (reachedLastPiece && !atLastPiece) {
                        // All pieces should lose their fixed position and move together
                        atLastPiece = true
                        cassettePieces.forEach(piece => {
                            // Remove fixed class from all pieces when reaching piece 5
                            if (piece.isFixed) {
                                piece.element.classList.remove('Cassette_fixed')
                                piece.isFixed = false
                                console.log(`REMOVED Cassette_fixed class from piece ${piece.index} (at last piece)`)
                            }
                        })
                        console.log('Reached last piece - all pieces unfixed')
                    }
                    
                    if (reachedLastPiece) {
                        // All pieces stay in their natural positions when unfixed
                        // No transform needed - they'll move naturally with the page
                    } else {
                        // Reset flag when not at last piece
                        atLastPiece = false
                        // Normal fixed behavior for individual pieces
                        cassettePieces.forEach(piece => {
                            // Reset transform when not at last piece
                            piece.element.style.transform = ''
                            
                            console.log(`Piece ${piece.index} - Scroll Y: ${scrollY}, Trigger: ${piece.triggerPoint}, Fixed: ${piece.isFixed}`)
                            
                            // Only add fixed class if not at last piece
                            if (!atLastPiece) {
                                // Add fixed class when we scroll past the trigger point
                                if (scrollY >= piece.triggerPoint - 100 && !piece.isFixed) {
                                    piece.element.classList.add('Cassette_fixed')
                                    piece.isFixed = true
                                    console.log(`ADDED Cassette_fixed class to piece ${piece.index}`)
                                } else if (scrollY < piece.triggerPoint - 100 && piece.isFixed) {
                                    // Remove fixed class when we scroll back above the trigger point
                                    piece.element.classList.remove('Cassette_fixed')
                                    piece.isFixed = false
                                    console.log(`REMOVED Cassette_fixed class from piece ${piece.index}`)
                                }
                            }
                        })
                    }
                }
                
                // Add scroll event listener
                window.addEventListener('scroll', checkCassettePositions, { passive: true })
                
                // Initial check
                checkCassettePositions()
                console.log('Scroll listener set up for all cassette pieces')
            } else {
                console.log('No cassette pieces found')
            }
2            // Process step background image fade-in animation
            
            
            // Wait for DOM to be fully loaded
            setTimeout(() => {
                const processSteps = document.querySelectorAll('.Process__step')
                const cassetteContainer = document.querySelector('.Cassette')
                
                
                
                // Initialize all process steps with opacity 0 for background images
                processSteps.forEach(step => {
                    step.style.position = 'relative'
                    step.style.setProperty('--bg-opacity', '0')
                })
    
                // Debug: log all cassette pieces
                for (let i = 1; i <= 5; i++) {
                    const piece = document.querySelector(`.Cassette_piece_${i}`)
                    
                }
                
                let fadeAnimationTriggered = false
                
                if (processSteps.length > 0) {
                    // Get all process titles for glow effect
                    const processTitles = document.querySelectorAll('.Process__title')
                    
                    function updateProcessAnimations() {
                        const scrollTop = window.pageYOffset || document.documentElement.scrollTop
                        const windowHeight = window.innerHeight
                        
                        // Check if first process step is in trigger range
                        const firstStep = processSteps[0]
                        if (firstStep) {
                            const stepRect = firstStep.getBoundingClientRect()
                            const stepTop = stepRect.top
                            const triggerPoint = windowHeight * 0.5
                            const fadeDistance = windowHeight * 0.3 // Fade over 30% of viewport height
                            
                            if (stepTop <= triggerPoint && stepTop > triggerPoint - fadeDistance) {
                                // First step is in fade-in range - apply to all steps
                                const progress = 1 - ((stepTop - (triggerPoint - fadeDistance)) / fadeDistance)
                                const opacity = Math.max(0, Math.min(1, progress))
                                
                                processSteps.forEach(step => {
                                    step.style.setProperty('--bg-opacity', opacity.toString())
                                })
                                
                                
                            } else if (stepTop <= triggerPoint - fadeDistance) {
                                // First step is fully visible - all backgrounds fully visible
                                processSteps.forEach(step => {
                                    step.style.setProperty('--bg-opacity', '1')
                                })
                            } else {
                                // First step hasn't entered fade range yet - all backgrounds hidden
                                processSteps.forEach(step => {
                                    step.style.setProperty('--bg-opacity', '0')
                                })
                            }
                        }
                        
                        // Check each process title for glow effect and track active step
                        let activeStepIndex = -1
                        
                        processTitles.forEach((title, index) => {
                            const rect = title.getBoundingClientRect()
                            const titleCenter = rect.top + rect.height / 2
                            const viewportCenter = windowHeight / 2
                            const glowTriggerZone = windowHeight * 0.6 // Glow when title is within 60% of viewport height
                            
                            // Calculate distance from viewport center
                            const distanceFromCenter = Math.abs(titleCenter - viewportCenter)
                            const maxDistance = glowTriggerZone / 2
                            
                            if (distanceFromCenter <= maxDistance) {
                                // Title is in glow zone - add glow class
                                title.classList.add('Process__title_glow')
                                activeStepIndex = index
                                
                                // Also make the corresponding process text fully visible
                                const processStep = title.closest('.Process__step')
                                if (processStep) {
                                    const processText = processStep.querySelector('.Process__text')
                                    if (processText) {
                                        processText.style.opacity = '1'
                                    }
                                }
                            } else {
                                // Title is out of glow zone - remove glow class
                                title.classList.remove('Process__title_glow')
                                
                                // Reset process text opacity to default
                                const processStep = title.closest('.Process__step')
                                if (processStep) {
                                    const processText = processStep.querySelector('.Process__text')
                                    if (processText) {
                                        processText.style.opacity = ''
                                    }
                                }
                            }
                        })
                        
                        // Fade previous steps based on active step
                        processSteps.forEach((step, index) => {
                            if (activeStepIndex >= 0 && index < activeStepIndex) {
                                // This is a previous step - fade it out
                                step.classList.add('Process__step_faded')
                            } else {
                                // This is current or future step - remove fade
                                step.classList.remove('Process__step_faded')
                            }
                        })
                    }
                    
                    // Add scroll event listener for process animations
                    window.addEventListener('scroll', updateProcessAnimations)
                    
                    // Initial call
                    updateProcessAnimations()
                } else {
                    
                }
            }, 1000) // Wait 1 second for DOM to be ready

        }
    },  
})