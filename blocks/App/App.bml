Beast.decl({
    App: {
        
        tag:'body',
        
        expand: function fn () {
            if (MissEvent.mobile) { this.mix('mobile') }
            this.append( <Noise />, <Form />, this.get() )
        },
        domInit: function fn() {
            // Add ASCII art for ARK studio
            console.log(`
          ++++++*+++++++=+==+==+=++=++=+=+======-=
        =+++++*+++*+++=+==+==+=++=++=++=+=====-=--
      =++++++++*++++++=+=+=+=+=+=+=+=++=+======-=---
    =+=++++++*+++++++=+=+===+=+=+++=+==+====-=----
  ==+=++++++*++*+++++=+==+=  =++=+=++=+====-=-----
===+=++++++*++*++++=+=+==    +=++++==+====-=------

MADE BY Î›RK / www.ark.studio/byld / 2025
            `);
            // Action elements shuffling animation using Shuffle helper
            if (typeof Shuffle !== 'undefined') {
                const actionElements = document.querySelectorAll('.Action, .Footer__action, .Button_Type_Action, .CaseAction')
                
                actionElements.forEach(element => {
                    Shuffle.animateHoverShuffle(element, {
                        charSet: Shuffle.charSets.latin,
                        swapsRemaining: element.textContent.length + 8,
                        interval: 30
                    })
                })
                

            } else {
                console.warn('Shuffle helper not found. Make sure shuffle.js is loaded.')
            }

            // Parallax scrolling for .Data, .Logo, .Case__head, .CaseMeta/.Divider_One, and .Case__image/.About/.Services elements with different speeds
            const caseHeadElements = document.querySelectorAll('.Case__head')
            const caseMetaElements = document.querySelectorAll('.CaseMeta')
            const dividerOneElements = document.querySelectorAll('.header.header_top')
            const caseImageElements = document.querySelectorAll('.Case__image')
            const aboutElements = document.querySelectorAll('.case__descr')
            const servicesElements = document.querySelectorAll('.Services')
            let ticking = false
            
            function updateParallax() {
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop
                const windowHeight = window.innerHeight
                
                // Data parallax effects moved to Data.bml domInit using ScrollFade helper
                
                // Logo parallax effects moved to Logo.bml domInit using ScrollFade helper
                
                // Case__head elements - same speed as Data elements with blur
                caseHeadElements.forEach(element => {
                    const parallaxSpeed = 0.7 // Same as Data - slower parallax with more lag effect
                    const yPos = -(scrollTop * (1 - parallaxSpeed))
                    
                    // Calculate blur based on element position relative to viewport
                    const elementRect = element.getBoundingClientRect()
                    const elementTop = elementRect.top
                    const elementBottom = elementRect.bottom
                    
                    let blurAmount = 0
                    
                    // Blur when element approaches or exits the top of viewport
                    if (elementTop < windowHeight * 0.20 && elementBottom > 0) {
                        // Element is in upper 20% of viewport or above
                        const triggerPoint = windowHeight * 0.15
                        const distanceFromTrigger = Math.max(0, triggerPoint - elementTop)
                        const maxDistance = triggerPoint + elementRect.height
                        const exitProgress = distanceFromTrigger / maxDistance
                        blurAmount = Math.min(exitProgress * 8, 8) // Max 8px blur (same as Data)
                    }
                    
                    element.style.transform = `translate3d(0, ${yPos}px, 0)`
                    element.style.filter = `blur(${blurAmount}px)`
                    element.style.willChange = 'transform, filter'
                })
                
                // CaseMeta and Divider_One elements - different speed than Case__head, move together
                const caseMetaGroupElements = [...caseMetaElements, ...dividerOneElements]
                caseMetaGroupElements.forEach(element => {
                    // Skip .header.header_top animation on mobile
                    if (MissEvent.mobile && element.classList.contains('header') && element.classList.contains('header_top')) {
                        return
                    }
                    
                    const parallaxSpeed = 0.8 // Faster than Data/Case__head (0.7) - less lag effect
                    const yPos = -(scrollTop * (1 - parallaxSpeed))
                    
                    // Calculate blur based on element position relative to viewport
                    const elementRect = element.getBoundingClientRect()
                    const elementTop = elementRect.top
                    const elementBottom = elementRect.bottom
                    
                    let blurAmount = 0
                    
                    // Blur when element approaches or exits the top of viewport
                    if (elementTop < windowHeight * 0.20 && elementBottom > 0) {
                        // Element is in upper 20% of viewport or above
                        const triggerPoint = windowHeight * 0.15
                        const distanceFromTrigger = Math.max(0, triggerPoint - elementTop)
                        const maxDistance = triggerPoint + elementRect.height
                        const exitProgress = distanceFromTrigger / maxDistance
                        blurAmount = Math.min(exitProgress * 8, 8) // Max 8px blur (same as other elements)
                    }
                    
                    element.style.transform = `translate3d(0, ${yPos}px, 0)`
                    element.style.filter = `blur(${blurAmount}px)`
                    element.style.willChange = 'transform, filter'
                })
                
                // Case__image, About, and Services elements - blur only (no parallax movement)
                const caseContentElements = [...caseImageElements, ...aboutElements, ...servicesElements]
                caseContentElements.forEach(element => {
                    // Calculate blur based on element position relative to viewport
                    const elementRect = element.getBoundingClientRect()
                    const elementTop = elementRect.top
                    const elementBottom = elementRect.bottom
                    
                    let blurAmount = 0
                    
                    // Blur when element approaches or exits the top of viewport
                    if (elementTop < windowHeight * 0.20 && elementBottom > 0) {
                        // Element is in upper 20% of viewport or above
                        const triggerPoint = windowHeight * 0.15
                        const distanceFromTrigger = Math.max(0, triggerPoint - elementTop)
                        const maxDistance = triggerPoint + elementRect.height
                        const exitProgress = distanceFromTrigger / maxDistance
                        blurAmount = Math.min(exitProgress * 8, 8) // Max 8px blur (same as other elements)
                    }
                    
                    // Only apply blur, no transform/movement
                    element.style.filter = `blur(${blurAmount}px)`
                    element.style.willChange = 'filter'
                })
                
                // Handle Text__item parallax blur
                const textItems = document.querySelectorAll('.Text__item')
                textItems.forEach(element => {
                    const elementRect = element.getBoundingClientRect()
                    const elementTop = elementRect.top
                    const elementBottom = elementRect.bottom
                    
                    let blurAmount = 0
                    
                    // Blur when element approaches or exits the top of viewport
                    if (elementTop < windowHeight * 0.20 && elementBottom > 0) {
                        // Element is in upper 20% of viewport or above
                        const triggerPoint = windowHeight * 0.15
                        const distanceFromTrigger = Math.max(0, triggerPoint - elementTop)
                        const maxDistance = triggerPoint + elementRect.height
                        const exitProgress = distanceFromTrigger / maxDistance
                        blurAmount = Math.min(exitProgress * 12, 12) // Max 12px blur (medium intensity)
                    }
                    
                    element.style.filter = `blur(${blurAmount}px)`
                    element.style.willChange = 'filter'
                })
                
                ticking = false
            }
            
            function requestParallaxUpdate() {
                if (!ticking) {
                    requestAnimationFrame(updateParallax)
                    ticking = true
                }
            }
            
            // Listen for scroll events
            window.addEventListener('scroll', requestParallaxUpdate, { passive: true })
            
            // Initial positioning
            updateParallax()

            // Text__item fade-in with character animation on page load
            const textItems = document.querySelectorAll('.Text__item')
            
            
            textItems.forEach((element, index) => {
                
                
                // Start animation after a delay based on index
                setTimeout(() => {
                    // Simple fade in and unblur
                    element.classList.add('Text__item_loaded')
                    
                    
                }, index * 1000) // 1 second delay between each item
            })









            // Services__item scroll-triggered fade/unblur animation moved to Services.bml domInit using helpers
            
            // Card scroll-triggered fade/unblur animation
            const cardItems = document.querySelectorAll('.Card')
            
            
            if (cardItems.length > 0) {
                const cardObserverOptions = {
                    root: null,
                    rootMargin: '0px 0px 0px 0px', // No margin - trigger exactly when entering/leaving
                    threshold: 0.1 // Very small threshold - almost completely out of view
                }
                
                let lastScrollY = window.scrollY
                
                const cardObserver = new IntersectionObserver((entries) => {
                    const currentScrollY = window.scrollY
                    const scrollingUp = currentScrollY < lastScrollY
                    lastScrollY = currentScrollY
                    
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            // Card is visible - animate if not already loaded
                            if (!entry.target.classList.contains('Card_loaded')) {
                                // Reset all cards first
                                cardItems.forEach(card => {
                                    card.classList.remove('Card_loaded')
                                })
                                
                                // Animate all cards in sequence
                                cardItems.forEach((card, index) => {
                                    setTimeout(() => {
                                        card.classList.add('Card_loaded')
                                        
                                    }, index * 150) // 150ms delay between each card
                                })
                            }
                        } else {
                            // Card is NOT visible
                            // Only reset when scrolling UP and card is out of viewport
                            if (scrollingUp) {
                                entry.target.classList.remove('Card_loaded')
                                
                            }
                            // Don't reset when scrolling down (card may be above viewport)
                        }
                    })
                }, cardObserverOptions)
                
                // Observe all card items
                cardItems.forEach(card => {
                    cardObserver.observe(card)
                })
            }
            

            // Scroll-triggered fade/unblur animation for Case__image, case__descr, case__solution, Review, and case__impact-bottom
            const scrollAnimationElements = [
                { selector: '.Case__image', className: 'Case__image_loaded' },
                { selector: '.Case__descr', className: 'Case__descr_loaded' },
                { selector: '.Case__solution', className: 'Case__solution_loaded' },
                { selector: '.Case__review', className: 'Case__review_loaded' },
                { selector: '.Case__impact-bottom', className: 'Case__impact-bottom_loaded' }
            ]
            
            scrollAnimationElements.forEach(({ selector, className }) => {
                const elements = document.querySelectorAll(selector)
                
                
                if (elements.length > 0) {
                    const observerOptions = {
                        root: null,
                        rootMargin: '0px 0px -20% 0px', // Trigger when 20% into viewport
                        threshold: 0.1
                    }
                    
                    const elementObserver = new IntersectionObserver((entries) => {
                        entries.forEach(entry => {
                            if (entry.isIntersecting) {
                                // Element is visible - animate
                                entry.target.classList.add(className)
                                
                            } else {
                                // Element is not visible - reset animation
                                entry.target.classList.remove(className)
                                
                            }
                        })
                    }, observerOptions)
                    
                    // Observe all elements of this type
                    elements.forEach(element => {
                        elementObserver.observe(element)
                    })
                }
            })

            // Scroll-triggered character shuffling animation for caseresult__item elements
            const scrollCaseresultItems = document.querySelectorAll('.caseresult__item')
            
            if (scrollCaseresultItems.length > 0) {
                const caseresultObserverOptions = {
                    root: null,
                    rootMargin: '0px 0px -20% 0px', // Trigger when 20% into viewport
                    threshold: 0.3
                }
                
                const caseresultObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            // caseresult__item is visible - trigger character animation
                            const item = entry.target
                            
                            // Find title and text elements within this item
                            const titleElement = item.querySelector('.caseresult__title')
                            const textElement = item.querySelector('.caseresult__text')
                            
                            // Animate title first, then text
                            if (titleElement) {
                                setTimeout(() => {
                                    animateCaseresultText(titleElement)
                                }, 100)
                            }
                            
                            if (textElement) {
                                setTimeout(() => {
                                    animateCaseresultText(textElement)
                                }, 300) // Start text animation 200ms after title
                            }
                            
                        }
                    })
                }, caseresultObserverOptions)
                
                // Function to animate caseresult text with character shuffling
                function animateCaseresultText(element) {
                    const text = element.textContent.trim()
                    if (text.length === 0) return
                    
                    // Split text into individual character spans
                    element.innerHTML = text.split('').map(char => '<span>' + char + '</span>').join('')
                    
                    const spans = element.querySelectorAll('span')
                    const originalText = text.split('')
                    
                    spans.forEach((span, index) => {
                        const delay = index * 30 // 30ms delay between letters
                        setTimeout(() => {
                            let rollCount = 0
                            const maxRolls = 15 // More character swaps for longer rolling effect
                            
                            const rollInterval = setInterval(() => {
                                if (rollCount < maxRolls) {
                                    // Random character from ASCII 33-126 (visible characters)
                                    const randomChar = String.fromCharCode(33 + Math.floor(Math.random() * 94))
                                    span.textContent = randomChar
                                    rollCount++
                                } else {
                                    // Animation complete - restore original character
                                    span.textContent = originalText[index]
                                    clearInterval(rollInterval)
                                }
                            }, 50) // 50ms between character swaps
                        }, delay)
                    })
                }
                
                // Observe all caseresult items
                scrollCaseresultItems.forEach(item => {
                    caseresultObserver.observe(item)
                })
            }

            // Reviews dimming when footer comes into view
            const reviewsElement = document.querySelector('.Reviews')
            const footerElement = document.querySelector('.Footer')
            
            
            if (reviewsElement && footerElement) {
                const footerObserverOptions = {
                    root: null,
                    rootMargin: '0px 0px 0px 0px', // Trigger when footer starts entering viewport
                    threshold: 0.4 // Trigger when 40% of footer is visible
                }
                
                const footerObserver = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            // Footer is entering viewport - dim reviews
                            reviewsElement.classList.add('Reviews_dimmed')
                            
                        } else {
                            // Footer is leaving viewport - restore reviews
                            reviewsElement.classList.remove('Reviews_dimmed')
                            
                        }
                    })
                }, footerObserverOptions)
                
                // Observe the footer
                footerObserver.observe(footerElement)
            }
            
            // Fallback: ensure all text items are visible after 5 seconds
            setTimeout(() => {
                textItems.forEach(element => {
                    if (!element.classList.contains('Text__item_loaded')) {
                        
                        element.classList.add('Text__item_loaded')
                    }
                })
            }, 5000)

            // Footer text animations moved to Footer.bml domInit using helper function

            


            // Process step background image fade-in animation
            
            
            // Wait for DOM to be fully loaded
            setTimeout(() => {
                const processSteps = document.querySelectorAll('.Process__step')
                const cassetteContainer = document.querySelector('.Cassette')
                
                
                
                // Initialize all process steps with opacity 0 for background images
                processSteps.forEach(step => {
                    step.style.position = 'relative'
                    step.style.setProperty('--bg-opacity', '0')
                })
    
                // Debug: log all cassette pieces
                for (let i = 1; i <= 5; i++) {
                    const piece = document.querySelector(`.Cassette_piece_${i}`)
                    
                }
                
                let fadeAnimationTriggered = false
                
                if (processSteps.length > 0) {
                    // Get all process titles for glow effect
                    const processTitles = document.querySelectorAll('.Process__title')
                    
                    function updateProcessAnimations() {
                        const scrollTop = window.pageYOffset || document.documentElement.scrollTop
                        const windowHeight = window.innerHeight
                        
                        // Check if first process step is in trigger range
                        const firstStep = processSteps[0]
                        if (firstStep) {
                            const stepRect = firstStep.getBoundingClientRect()
                            const stepTop = stepRect.top
                            const triggerPoint = windowHeight * 0.5
                            const fadeDistance = windowHeight * 0.3 // Fade over 30% of viewport height
                            
                            if (stepTop <= triggerPoint && stepTop > triggerPoint - fadeDistance) {
                                // First step is in fade-in range - apply to all steps
                                const progress = 1 - ((stepTop - (triggerPoint - fadeDistance)) / fadeDistance)
                                const opacity = Math.max(0, Math.min(1, progress))
                                
                                processSteps.forEach(step => {
                                    step.style.setProperty('--bg-opacity', opacity.toString())
                                })
                                
                                
                            } else if (stepTop <= triggerPoint - fadeDistance) {
                                // First step is fully visible - all backgrounds fully visible
                                processSteps.forEach(step => {
                                    step.style.setProperty('--bg-opacity', '1')
                                })
                            } else {
                                // First step hasn't entered fade range yet - all backgrounds hidden
                                processSteps.forEach(step => {
                                    step.style.setProperty('--bg-opacity', '0')
                                })
                            }
                        }
                        
                        // Check each process title for glow effect and track active step
                        let activeStepIndex = -1
                        
                        processTitles.forEach((title, index) => {
                            const rect = title.getBoundingClientRect()
                            const titleCenter = rect.top + rect.height / 2
                            const viewportCenter = windowHeight / 2
                            const glowTriggerZone = windowHeight * 0.6 // Glow when title is within 60% of viewport height
                            
                            // Calculate distance from viewport center
                            const distanceFromCenter = Math.abs(titleCenter - viewportCenter)
                            const maxDistance = glowTriggerZone / 2
                            
                            if (distanceFromCenter <= maxDistance) {
                                // Title is in glow zone - add glow class
                                title.classList.add('Process__title_glow')
                                activeStepIndex = index
                                
                                // Also make the corresponding process text fully visible
                                const processStep = title.closest('.Process__step')
                                if (processStep) {
                                    const processText = processStep.querySelector('.Process__text')
                                    if (processText) {
                                        processText.style.opacity = '1'
                                    }
                                }
                            } else {
                                // Title is out of glow zone - remove glow class
                                title.classList.remove('Process__title_glow')
                                
                                // Reset process text opacity to default
                                const processStep = title.closest('.Process__step')
                                if (processStep) {
                                    const processText = processStep.querySelector('.Process__text')
                                    if (processText) {
                                        processText.style.opacity = ''
                                    }
                                }
                            }
                        })
                        
                        // Fade previous steps based on active step
                        processSteps.forEach((step, index) => {
                            if (activeStepIndex >= 0 && index < activeStepIndex) {
                                // This is a previous step - fade it out
                                step.classList.add('Process__step_faded')
                            } else {
                                // This is current or future step - remove fade
                                step.classList.remove('Process__step_faded')
                            }
                        })
                    }
                    
                    // Add scroll event listener for process animations
                    window.addEventListener('scroll', updateProcessAnimations)
                    
                    // Initial call
                    updateProcessAnimations()
                } else {
                    
                }
            }, 1000) // Wait 1 second for DOM to be ready

        }
    },  
})