Beast.decl({
    Cassette: {
        domInit: function fn() {
            // Cassette pieces scroll detection for fixed positioning
            const cassettePieces = []
            
            // Configuration for viewport-relative positioning
            const config = {
                // Offset as percentage of viewport height (instead of fixed pixels)
                triggerOffset: 0.15,  // 15% of viewport height
                // Minimum scroll delta to prevent micro-movements
                minScrollDelta: 0.02, // 2% of viewport height (increased for smoother movement)

                // Mobile breakpoint
                mobileBreakpoint: 768,

                // Debounce resize events
                resizeDebounce: 250,

                // Mobile and Desktop configurations
                mobile: {
                    triggerOffset: 360, // Reduced from 360 to make pieces fix earlier
                    minScrollDelta: 0 // 2% of viewport height
                },
                desktop: {
                    triggerOffset: 0.14, // Increased to 25% to fix pieces earlier on desktop
                    minScrollDelta: 0.02 // 2% of viewport height
                }
            }
            
            // Get all cassette pieces
            for (let i = 1; i <= 5; i++) {
                const piece = document.querySelector(`.Cassette_piece_${i}`)
                if (piece) {
                    cassettePieces.push({
                        element: piece,
                        index: i,
                        isFixed: false,
                        triggerPoint: 0, // Will be calculated dynamically
                        lastPosition: 0 // Track last position to prevent jiggle
                    })
                }
            }
            
            if (cassettePieces.length > 0) {
                
                // MOBILE ONLY: DOM reorganization for better mobile layout
                function setupMobileLayout() {
                    if (!MissEvent.mobile) return // Desktop: do nothing
                    
                    const processElement = document.querySelector('.Process')
                    if (!processElement) return
                    
                    // Create mobile container inside .Process (mobile only)
                    let mobileContainer = document.querySelector('.mobile-cassette-container')
                    if (!mobileContainer) {
                        mobileContainer = document.createElement('div')
                        mobileContainer.className = 'mobile-cassette-container'
                        processElement.appendChild(mobileContainer)
                    }
                    
                    // Move cassette pieces to mobile container (mobile only)
                    cassettePieces.forEach(piece => {
                        mobileContainer.appendChild(piece.element)
                    })
                    
                    console.log('Mobile cassette layout setup complete')
                }
                
                // Initialize mobile layout
                setupMobileLayout()
                
                // Function to calculate trigger points dynamically with mobile/desktop support
                function calculateTriggerPoints() {
                    const windowHeight = window.innerHeight
                    
                    cassettePieces.forEach(piece => {
                        const rect = piece.element.getBoundingClientRect()
                        
                        if (MissEvent.mobile) {
                            // MOBILE ONLY: Enhanced cascading animation with process-based timing
                            const processSection = document.querySelector('#process')
                            const processRect = processSection ? processSection.getBoundingClientRect() : rect
                            const processTop = processRect.top + window.scrollY
                            
                            // Mobile: Align each piece with its corresponding process step
                            const correspondingStep = document.querySelector(`.Process__step_0${piece.index}`)
                            if (correspondingStep) {
                                const stepRect = correspondingStep.getBoundingClientRect()
                                const stepTop = stepRect.top + window.scrollY
                                
                                // All pieces appear before their corresponding step
                                // Piece 1 appears earliest, others appear progressively closer to their steps
                                const offsetMultiplier = piece.index === 1 ? 1.2 : 0.9
                                piece.triggerPoint = stepTop - (windowHeight * offsetMultiplier)
                            } else {
                                // Fallback: Use spread timing if step not found
                                const baseTrigger = processTop + (windowHeight * 0.1)
                                const cascadeInterval = windowHeight * 0.4 // Even longer fallback
                                piece.triggerPoint = baseTrigger + (piece.index - 1) * cascadeInterval
                            }
                        } else {
                            // Desktop: Use viewport-relative offset
                            const offsetVh = windowHeight * config.desktop.triggerOffset
                            piece.triggerPoint = rect.top + window.scrollY - offsetVh
                        }
                        
                        // Only update if the change is significant (prevents micro-adjustments)
                        if (Math.abs(piece.triggerPoint - piece.lastPosition) > 10) {
                            piece.lastPosition = piece.triggerPoint
                        }
                    })
                }
                
                // Calculate initial trigger points
                calculateTriggerPoints()
                
                // Optimized scroll handler with viewport-relative positioning
                let lastScrollY = 0
                let ticking = false
                let lastWindowHeight = window.innerHeight
                
                function checkCassettePositions() {
                    const scrollY = window.scrollY
                    const windowHeight = window.innerHeight
                    const scrollDelta = Math.abs(scrollY - lastScrollY)
                    const minDelta = windowHeight * config.minScrollDelta
                    
                    // Only process if scroll amount is significant (prevents micro-movements)
                    if (scrollDelta < minDelta) return
                    
                    // Check if viewport height changed significantly (only recalculate when needed)
                    if (Math.abs(windowHeight - lastWindowHeight) > 50) {
                        calculateTriggerPoints()
                        lastWindowHeight = windowHeight
                    }
                    
                    lastScrollY = scrollY
                    
                    // Get piece 5 trigger point for unfixing pieces 1-4
                    const piece5 = cassettePieces[4] // piece 5 is at index 4
                    const reachedPiece5 = piece5 && scrollY >= piece5.triggerPoint
                    
                    // Debug: Log scroll state on mobile
                    if (MissEvent.mobile) {
                        console.log(`=== SCROLL CHECK: scrollY=${scrollY} ===`)
                    }
                    
                    // Process each piece for cascading effect
                    cassettePieces.forEach(piece => {
                        const shouldBeFixed = scrollY >= piece.triggerPoint
                        
                        // MOBILE: Include all pieces (including piece 5) in cascade
                        // DESKTOP: Exclude piece 5 (preserve original behavior)
                        const includePiece5 = MissEvent.mobile
                        const shouldIncludePiece = includePiece5 || piece.index !== 5
                        
                        // Debug: Log state for ALL pieces on mobile
                        if (MissEvent.mobile) {
                            console.log(`Piece ${piece.index}: triggerPoint=${piece.triggerPoint}, shouldBeFixed=${shouldBeFixed}, isFixed=${piece.isFixed}, shouldIncludePiece=${shouldIncludePiece}`)
                        }
                        
                        // Add fixed class when scrolling past trigger point
                        if (shouldBeFixed && !piece.isFixed && shouldIncludePiece) {
                            piece.element.classList.add('Cassette_fixed')
                            piece.isFixed = true
                            
                            // MOBILE ONLY: Add animation effect
                            if (MissEvent.mobile) {
                                piece.element.classList.add('Cassette_animating')
                                setTimeout(() => {
                                    piece.element.classList.remove('Cassette_animating')
                                }, 300)
                            }
                        }
                        
                        // Remove fixed class if scrolling back up
                        // MOBILE: Allow full reverse animation - just use normal trigger points
                        // DESKTOP: Original behavior with piece 5 unfixing
                        const shouldBeUnfixed = MissEvent.mobile 
                            ? !shouldBeFixed 
                            : (!shouldBeFixed || (reachedPiece5 && piece.index !== 5))
                        
                        // Debug logging for all pieces on mobile
                        if (MissEvent.mobile && piece.isFixed) {
                            console.log(`Piece ${piece.index}: scrollY=${scrollY}, triggerPoint=${piece.triggerPoint}, shouldBeFixed=${shouldBeFixed}, shouldBeUnfixed=${shouldBeUnfixed}, isFixed=${piece.isFixed}`)
                        }
                        
                        if (shouldBeUnfixed && piece.isFixed) {
                            console.log(`Piece ${piece.index}: Starting reverse animation (mobile: ${MissEvent.mobile})`)
                            piece.element.classList.remove('Cassette_fixed')
                            piece.isFixed = false
                            console.log(`Piece ${piece.index}: Removed Cassette_fixed class`)
                            
                            // MOBILE ONLY: Add animation effect after unfixing
                            if (MissEvent.mobile) {
                                piece.element.classList.add('Cassette_animating')
                                console.log(`Piece ${piece.index}: Added Cassette_animating class`)
                                setTimeout(() => {
                                    piece.element.classList.remove('Cassette_animating')
                                    console.log(`Piece ${piece.index}: Removed Cassette_animating class - animation complete`)
                                }, 300)
                            }
                        }
                    })
                }
                
                function throttledCheckCassettePositions() {
                    if (!ticking) {
                        requestAnimationFrame(() => {
                            checkCassettePositions()
                            ticking = false
                        })
                        ticking = true
                    }
                }
                
                // Add scroll event listener for immediate response
                window.addEventListener('scroll', checkCassettePositions, { passive: true })
                
                // Debounced resize listener to prevent excessive recalculations
                let resizeTimeout
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout)
                    resizeTimeout = setTimeout(() => {
                        // Recalculate trigger points after resize
                        calculateTriggerPoints()
                        lastWindowHeight = window.innerHeight
                        // Force a check after resize
                        checkCassettePositions()
                    }, config.resizeDebounce)
                })
                
                // Cleanup function to reset all pieces
                function resetAllCassettePieces() {
                    cassettePieces.forEach(piece => {
                        piece.element.classList.remove('Cassette_fixed')
                        piece.isFixed = false
                        piece.element.style.transform = ''
                    })
                }
                
                // Expose reset function globally for debugging
                window.resetCassettePieces = resetAllCassettePieces
                
                // Initial check
                checkCassettePositions()
    
            } else {
                // No cassette pieces found
            }
        }       
    }
})